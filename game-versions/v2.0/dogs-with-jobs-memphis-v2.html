<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dogs With Jobs: Corporate Edition 📊</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<style>
  :root {
    --coral: #E76F51;
    --teal: #65C3BA;
    --navy: #2A4B8D;
    --cream: #FAF0E6;
    --yellow: #F4A261;
    --pink: #E9C46A;
    
    --bg-main: #FAF0E6;
    --bg-card: #FFFFFF;
    --bg-dark: #2A4B8D;
    
    --text-primary: #2A4B8D;
    --text-secondary: #5A7BB5;
    --text-light: #8B9DC3;
    
    --shadow-sm: 0 2px 4px rgba(42, 75, 141, 0.1);
    --shadow-md: 0 4px 8px rgba(42, 75, 141, 0.15);
    --shadow-lg: 0 8px 16px rgba(42, 75, 141, 0.2);
    --shadow-xl: 0 16px 32px rgba(42, 75, 141, 0.3);
    
    --gradient-coral: linear-gradient(135deg, #E76F51, #FF8B6F);
    --gradient-teal: linear-gradient(135deg, #65C3BA, #7FD8CF);
    --gradient-navy: linear-gradient(135deg, #2A4B8D, #3A5BA0);
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Inter', sans-serif;
    background: var(--bg-main);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
    position: relative;
  }

  /* Memphis Background Pattern */
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    opacity: 0.1;
    pointer-events: none;
    background-image: 
      radial-gradient(circle at 20% 30%, var(--coral) 0%, transparent 50%),
      radial-gradient(circle at 80% 60%, var(--teal) 0%, transparent 40%),
      radial-gradient(circle at 40% 80%, var(--yellow) 0%, transparent 30%);
    z-index: -2;
  }

  /* Grid Pattern */
  .grid-bg {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: 
      linear-gradient(var(--navy) 1px, transparent 1px),
      linear-gradient(90deg, var(--navy) 1px, transparent 1px);
    background-size: 50px 50px;
    opacity: 0.03;
    pointer-events: none;
    z-index: -1;
  }

  /* Geometric Decorations */
  .geo-decor {
    position: fixed;
    pointer-events: none;
  }
  
  .geo-1 {
    top: 10%;
    left: 5%;
    width: 80px;
    height: 80px;
    background: var(--coral);
    transform: rotate(45deg);
    opacity: 0.2;
    border-radius: 10px;
  }
  
  .geo-2 {
    top: 60%;
    right: 10%;
    width: 100px;
    height: 100px;
    border: 3px solid var(--teal);
    border-radius: 50%;
    opacity: 0.3;
  }
  
  .geo-3 {
    bottom: 15%;
    left: 10%;
    width: 0;
    height: 0;
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 70px solid var(--yellow);
    opacity: 0.2;
  }

  /* Header */
  header {
    background: linear-gradient(135deg, var(--bg-card), #f8f8f8);
    border-bottom: 4px solid var(--navy);
    padding: 1rem 2rem;
    box-shadow: var(--shadow-lg);
    position: sticky;
    top: 0;
    z-index: 500;
  }

  .header-content {
    max-width: 1600px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 2rem;
  }

  .logo-section {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .logo-badge {
    width: 45px;
    height: 45px;
    background: linear-gradient(135deg, var(--coral), var(--teal));
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    box-shadow: var(--shadow-md);
    transform: rotate(-5deg);
    animation: wiggle 3s ease-in-out infinite;
  }
  
  @keyframes wiggle {
    0%, 100% { transform: rotate(-5deg); }
    50% { transform: rotate(5deg); }
  }

  h1 {
    font-family: 'Space Grotesk', sans-serif;
    font-weight: 700;
    font-size: 1.5rem;
    color: var(--text-primary);
  }
  
  /* Status Display in Header */
  .header-status {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2rem;
  }
  
  .status-badge {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 0.5rem 1rem;
    background: var(--bg-main);
    border: 2px solid var(--navy);
    border-radius: 8px;
    position: relative;
  }
  
  .status-badge::after {
    content: '';
    position: absolute;
    bottom: -6px;
    left: 50%;
    transform: translateX(-50%);
    width: 60%;
    height: 3px;
    background: var(--gradient-coral);
    border-radius: 2px;
  }
  
  .status-badge-label {
    font-size: 0.65rem;
    text-transform: uppercase;
    color: var(--text-secondary);
    font-weight: 600;
    letter-spacing: 0.5px;
  }
  
  .status-badge-value {
    font-size: 1.2rem;
    font-weight: 700;
    background: var(--gradient-coral);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  
  /* Gear Menu */
  .gear-menu {
    position: relative;
  }
  
  .gear-btn {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background: var(--gradient-navy);
    border: none;
    color: white;
    font-size: 1.3rem;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: var(--shadow-md);
  }
  
  .gear-btn:hover {
    transform: rotate(90deg);
    box-shadow: var(--shadow-lg);
  }
  
  .gear-dropdown {
    position: absolute;
    top: 55px;
    right: 0;
    background: var(--bg-card);
    border: 2px solid var(--navy);
    border-radius: 8px;
    box-shadow: var(--shadow-xl);
    display: none;
    min-width: 150px;
    overflow: hidden;
  }
  
  .gear-dropdown.open {
    display: block;
  }
  
  .gear-dropdown button {
    width: 100%;
    padding: 0.75rem 1rem;
    border: none;
    background: transparent;
    color: var(--text-primary);
    font-weight: 600;
    text-align: left;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  .gear-dropdown button:hover {
    background: var(--gradient-teal);
    color: white;
  }

  /* Buttons */
  .btn {
    padding: 0.75rem 1.5rem;
    border: 2px solid var(--navy);
    background: var(--bg-card);
    color: var(--text-primary);
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    font-family: 'Space Grotesk', sans-serif;
    box-shadow: 3px 3px 0 var(--navy);
  }

  .btn:hover {
    transform: translate(-2px, -2px);
    box-shadow: 5px 5px 0 var(--navy);
  }

  .btn:active {
    transform: translate(0, 0);
    box-shadow: 1px 1px 0 var(--navy);
  }

  .btn-primary {
    background: var(--coral);
    color: white;
  }

  .btn-secondary {
    background: var(--teal);
    color: white;
  }

  /* Layout */
  .game-container {
    display: grid;
    grid-template-columns: 550px minmax(500px, 600px) 320px;
    gap: 1.5rem;
    padding: 1.5rem;
    max-width: 1600px;
    margin: 0 auto;
    justify-content: center;
  }

  /* Cards */
  .card {
    background: linear-gradient(135deg, var(--bg-card), #fcfcfc);
    border: 2px solid var(--navy);
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: var(--shadow-lg);
    position: relative;
    transition: all 0.3s;
  }
  
  .card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-xl);
  }

  .card::before {
    content: '';
    position: absolute;
    top: -5px;
    right: -5px;
    width: 20px;
    height: 20px;
    background: var(--yellow);
    border-radius: 50%;
    z-index: -1;
    animation: pulse 2s ease-in-out infinite;
  }
  
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }

  .card-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  /* 3D Board Container */
  .board-container {
    position: relative;
  }

  #canvas3d {
    width: 100%;
    height: 450px;
    border-radius: 8px;
    background: linear-gradient(135deg, #f5f5f5, #e0e0e0);
  }

  /* Camera Controls */
  .camera-controls {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
    justify-content: center;
  }

  .cam-btn {
    padding: 0.5rem 1rem;
    background: var(--bg-card);
    border: 2px solid var(--navy);
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s;
  }

  .cam-btn:hover {
    background: var(--teal);
    color: white;
  }

  /* Compact Leaderboard */
  .compact-leaderboard {
    display: flex;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--gradient-teal);
    border-radius: 8px;
    margin-top: 1rem;
    overflow-x: auto;
  }
  
  .leader-chip {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: var(--bg-card);
    border: 2px solid var(--navy);
    border-radius: 20px;
    white-space: nowrap;
    font-size: 0.85rem;
    font-weight: 600;
    box-shadow: var(--shadow-sm);
    transition: all 0.2s;
  }
  
  .leader-chip:hover {
    transform: scale(1.05);
    box-shadow: var(--shadow-md);
  }
  
  .leader-chip.first {
    background: var(--gradient-coral);
    color: white;
    border-color: var(--coral);
  }
  
  .leader-rank {
    width: 22px;
    height: 22px;
    background: var(--navy);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: 700;
  }
  
  .leader-chip.first .leader-rank {
    background: white;
    color: var(--coral);
  }

  /* Camera Info Bar */
  .camera-info {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem;
    background: rgba(42, 75, 141, 0.1);
    border-radius: 6px;
    margin-top: 0.5rem;
    font-size: 0.85rem;
  }
  
  .camera-mode {
    font-weight: 600;
    color: var(--text-primary);
  }

  /* Projects Grid */
  .projects-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
  }

  .project-card {
    background: linear-gradient(135deg, var(--bg-card), #fcfcfc);
    border: 3px solid var(--navy);
    border-radius: 8px;
    padding: 1rem;
    min-height: 180px;
    position: relative;
    transition: all 0.2s;
    cursor: move;
  }

  .project-card::after {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 10px;
    right: 10px;
    height: 5px;
    background: var(--gradient-teal);
    border-radius: 2px;
    opacity: 0;
    transition: opacity 0.2s;
  }

  .project-card.drag-over {
    transform: scale(1.05);
    border-color: var(--teal);
    box-shadow: 0 0 20px rgba(101, 195, 186, 0.4);
  }
  
  .project-card.drag-over::after {
    opacity: 1;
  }

  .project-card:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-xl);
  }

  .project-tier {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    background: var(--yellow);
    color: var(--text-primary);
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.7rem;
    font-weight: 700;
    text-transform: uppercase;
  }

  .project-name {
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 0.75rem;
  }

  .project-cost {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .energy-badge {
    background: var(--bg-main);
    border: 1px solid var(--navy);
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .bid-indicators {
    position: absolute;
    bottom: 0.5rem;
    left: 0.5rem;
    display: flex;
    gap: 0.25rem;
  }

  .bid-chip {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: 700;
    color: white;
    box-shadow: var(--shadow-sm);
  }

  /* Hand Cards - Balatro Style */
  .hand-container {
    display: flex;
    padding: 1rem;
    justify-content: center;
    min-height: 200px;
    align-items: center;
    overflow: visible;
  }
  
  .hand-container .action-card {
    margin-right: -45px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
  }
  
  .hand-container .action-card:last-child {
    margin-right: 0;
  }

  .action-card {
    background: linear-gradient(135deg, var(--bg-card), #f8f8f8);
    border: 2px solid var(--navy);
    border-radius: 8px;
    padding: 1rem;
    min-width: 120px;
    width: 120px;
    height: 170px;
    cursor: grab;
    transition: all 0.2s;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    box-shadow: var(--shadow-md);
    flex-shrink: 0;
  }

  .action-card:hover {
    transform: translateY(-25px) rotate(-3deg) scale(1.05);
    z-index: 10;
    box-shadow: var(--shadow-xl);
    border-color: var(--coral);
  }

  .action-card.dragging {
    cursor: grabbing;
    opacity: 0.5;
    transform: rotate(5deg);
  }

  .card-name {
    font-size: 0.85rem;
    font-weight: 700;
    color: var(--text-primary);
  }

  .card-energy {
    display: flex;
    gap: 0.25rem;
    flex-wrap: wrap;
  }

  /* Distraction Panel */
  .distraction-panel {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-card);
    border: 2px solid var(--navy);
    border-radius: 12px;
    padding: 1rem;
    display: flex;
    gap: 0.75rem;
    box-shadow: var(--shadow-lg);
    z-index: 100;
  }

  .distraction-card {
    width: 80px;
    height: 110px;
    background: linear-gradient(135deg, var(--coral), var(--yellow));
    border: 2px solid var(--navy);
    border-radius: 6px;
    padding: 0.5rem;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .distraction-card .card-back {
    text-align: center;
  }

  .distraction-card .card-owner {
    font-size: 0.65rem;
    font-weight: 700;
    color: white;
    margin-bottom: 0.5rem;
  }

  .distraction-card .card-icon {
    font-size: 2rem;
  }

  .distraction-card .card-content {
    display: none;
    position: absolute;
    inset: 0;
    padding: 0.5rem;
    background: inherit;
    border-radius: 4px;
  }

  .distraction-card:hover {
    transform: translateY(-15px) scale(1.4);
    z-index: 1000;
    box-shadow: var(--shadow-lg);
  }

  .distraction-card:hover .card-back {
    display: none;
  }

  .distraction-card:hover .card-content {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }

  /* Players Sidebar */
  .players-sidebar {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .player-card {
    background: var(--bg-card);
    border: 2px solid var(--navy);
    border-radius: 8px;
    padding: 1rem;
    position: relative;
    transition: all 0.2s;
  }

  .player-card.active {
    border-color: var(--coral);
    box-shadow: 0 0 0 3px rgba(231, 111, 81, 0.2);
  }

  .player-card.active::before {
    content: 'ACTIVE';
    position: absolute;
    top: -10px;
    right: 1rem;
    background: var(--coral);
    color: white;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    font-size: 0.6rem;
    font-weight: 700;
  }

  .player-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
  }

  .player-avatar {
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, var(--teal), var(--coral));
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
  }

  .player-info {
    flex: 1;
  }

  .player-name {
    font-weight: 700;
    color: var(--text-primary);
  }

  .player-breed {
    font-size: 0.8rem;
    color: var(--text-secondary);
  }

  .hidden-agenda {
    margin-top: 0.5rem;
    padding: 0.5rem;
    background: var(--bg-main);
    border-radius: 4px;
    font-size: 0.8rem;
    border: 1px dashed var(--navy);
  }

  .hidden-agenda.concealed {
    filter: blur(6px);
    user-select: none;
  }
  
  /* Tooltips */
  .tooltip {
    position: absolute;
    background: var(--bg-dark);
    color: white;
    padding: 0.75rem;
    border-radius: 6px;
    font-size: 0.85rem;
    z-index: 1000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    max-width: 250px;
    box-shadow: var(--shadow-xl);
  }
  
  .tooltip.show {
    opacity: 1;
  }
  
  .breed-info {
    cursor: help;
    text-decoration: underline;
    text-decoration-style: dotted;
    text-underline-offset: 2px;
  }

  /* Game Notification */
  .notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--bg-card);
    border: 3px solid var(--navy);
    border-radius: 12px;
    padding: 2rem;
    z-index: 2000;
    display: none;
    box-shadow: var(--shadow-lg);
    text-align: center;
    min-width: 300px;
  }

  .notification.show {
    display: block;
    animation: popIn 0.3s ease-out;
  }

  @keyframes popIn {
    from {
      transform: translate(-50%, -50%) scale(0.8);
      opacity: 0;
    }
    to {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
  }

  .notification-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--coral);
    margin-bottom: 0.5rem;
  }

  .notification-message {
    color: var(--text-primary);
  }

  /* Target Selection Modal */
  .target-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--bg-card);
    border: 3px solid var(--navy);
    border-radius: 12px;
    padding: 2rem;
    z-index: 1500;
    display: none;
    box-shadow: var(--shadow-lg);
  }

  .target-modal.active {
    display: block;
  }

  .target-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 1.5rem;
    text-align: center;
  }

  .target-players {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .target-player {
    background: var(--bg-main);
    border: 2px solid var(--navy);
    border-radius: 8px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
  }

  .target-player:hover {
    background: var(--teal);
    color: white;
    transform: scale(1.05);
  }

  /* Results Log */
  .results-log {
    max-height: 150px;
    overflow-y: auto;
    background: var(--bg-main);
    border: 1px solid var(--navy);
    border-radius: 6px;
    padding: 0.5rem;
    margin-top: 1rem;
  }

  .result-entry {
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    background: var(--bg-card);
    border-radius: 4px;
    font-size: 0.85rem;
  }

  /* Turn Controls */
  .turn-controls {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 1rem;
  }

  .cards-indicator {
    padding: 0.5rem 1rem;
    background: var(--bg-main);
    border: 2px solid var(--navy);
    border-radius: 6px;
    font-weight: 600;
    color: var(--text-primary);
  }

  /* Responsive */
  @media (max-width: 1400px) {
    .game-container {
      grid-template-columns: 1fr;
    }
  }
  
  /* Debug Panel */
  .debug-panel {
    position: fixed;
    top: 80px;
    right: 20px;
    width: 320px;
    max-height: 80vh;
    background: #FAF0E6;
    border: 3px solid #2A4B8D;
    border-radius: 12px;
    padding: 20px;
    z-index: 10000;
    overflow-y: auto;
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
  }
  
  .debug-panel h3 {
    color: #2A4B8D;
    margin: 0 0 15px;
    font-size: 1.5rem;
  }
  
  .debug-panel h4 {
    color: #E76F51;
    margin: 10px 0 5px;
    font-size: 1.1rem;
  }
  
  .debug-section {
    background: white;
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 15px;
    border: 2px solid #65C3BA;
  }
  
  .debug-section button {
    margin: 3px;
    padding: 5px 10px;
    font-size: 0.9rem;
  }
  
  .debug-section select {
    width: 100%;
    margin-bottom: 5px;
  }
  
  #debugAgendas {
    font-size: 0.85rem;
    line-height: 1.4;
  }
  
  .debug-agenda-item {
    padding: 5px;
    margin: 3px 0;
    background: #F4A261;
    border-radius: 4px;
  }
</style>
</head>
<body>
<div class="grid-bg"></div>
<div class="geo-decor geo-1"></div>
<div class="geo-decor geo-2"></div>
<div class="geo-decor geo-3"></div>

<header>
  <div class="header-content">
    <div class="logo-section">
      <div class="logo-badge">🐕</div>
      <div>
        <h1>Dogs With Jobs</h1>
        <div class="subtitle">Corporate Ladder Championship</div>
      </div>
    </div>
    <div class="header-status">
      <div class="status-badge">
        <span style="font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);">TURN</span>
        <span id="turnDisplay" style="font-size: 1.25rem; font-weight: 700; background: var(--gradient-coral); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">1</span>
      </div>
      <div class="status-badge">
        <span style="font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);">PHASE</span>
        <span id="phaseDisplay" style="font-size: 1rem; font-weight: 700; color: var(--text-primary);">Setup</span>
      </div>
      <div class="status-badge">
        <span style="font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);">LEADER</span>
        <span id="leaderDisplay" style="font-size: 1rem; font-weight: 700; color: var(--text-primary);">-</span>
      </div>
    </div>
    <div class="gear-menu">
      <button class="gear-btn" onclick="game.toggleGearMenu()">⚙️</button>
      <div class="gear-dropdown" id="gearDropdown">
        <button onclick="game.newGame()">New Game</button>
        <button onclick="game.saveGame()">Save Game</button>
        <button onclick="game.loadGame()">Load Game</button>
        <button onclick="game.toggleDebugPanel()">Debug Panel</button>
      </div>
    </div>
  </div>
</header>

<div class="game-container">
  <!-- Board Section -->
  <div>
    <div class="card board-container">
      <h2 class="card-title">🏢 Corporate Ladder</h2>
      <div id="canvas3d"></div>
      <div class="camera-controls">
        <button class="cam-btn" onclick="game.setCameraView('top')">Top View</button>
        <button class="cam-btn" onclick="game.setCameraView('side')">Side View</button>
        <button class="cam-btn" onclick="game.setCameraView('follow')">Follow Leader</button>
        <button class="cam-btn" onclick="game.resetCamera()">Reset</button>
      </div>
    </div>
    
    <div class="compact-leaderboard" id="compactLeaderboard"></div>
    
    
    <div class="results-log" id="resultsLog"></div>
  </div>

  <!-- Center Section -->
  <div>
    <div class="card">
      <h2 class="card-title">📋 Active Projects - Round <span id="roundNum">1</span>/3</h2>
      <div class="projects-grid" id="projectsGrid"></div>
    </div>

    <div class="card">
      <h2 class="card-title">🎴 <span id="currentPlayerName">Player</span>'s Hand</h2>
      <div class="cards-indicator" id="cardsIndicator">Cards Played: 0/1</div>
      <div class="hand-container" id="handContainer"></div>
      <div class="turn-controls">
        <button class="btn btn-primary" id="endBiddingBtn" onclick="game.endBidding()">End Bidding</button>
        <button class="btn btn-secondary" id="endDistractionBtn" onclick="game.endDistraction()" style="display: none;">Done with Distractions</button>
        <button class="btn" onclick="game.undoLastBid()">Undo</button>
      </div>
    </div>
  </div>

  <!-- Players Sidebar -->
  <div class="players-sidebar" id="playersSidebar"></div>
</div>

<!-- Distraction Panel -->
<div class="distraction-panel" id="distractionPanel"></div>

<!-- Game Notification -->
<div class="notification" id="notification">
  <div class="notification-title" id="notificationTitle">Notification</div>
  <div class="notification-message" id="notificationMessage">Message</div>
</div>

<!-- Target Selection Modal -->
<div class="target-modal" id="targetModal">
  <div class="target-title">Select Target Player</div>
  <div class="target-players" id="targetPlayers"></div>
  <button class="btn" onclick="game.cancelTargeting()" style="width: 100%; margin-top: 1rem;">Cancel</button>
</div>

<!-- Debug Panel -->
<div id="debugPanel" class="debug-panel" style="display: none;">
  <h3>🐛 Debug Panel</h3>
  <div class="debug-section">
    <h4>Test Win Conditions</h4>
    <select id="debugPlayer" class="btn">
      <option value="0">Player 1</option>
      <option value="1">Player 2</option>
      <option value="2">Player 3</option>
      <option value="3">Player 4</option>
    </select>
    <button class="btn" onclick="game.testWinCondition()">Check Win</button>
  </div>
  
  <div class="debug-section">
    <h4>Modify Player State</h4>
    <button class="btn" onclick="game.modifyPosition(10)">+10 Position</button>
    <button class="btn" onclick="game.modifyPosition(-10)">-10 Position</button>
    <button class="btn" onclick="game.addCompletedProject()">+1 Project</button>
    <button class="btn" onclick="game.addDistraction()">+1 Distraction</button>
  </div>
  
  <div class="debug-section">
    <h4>Game State</h4>
    <button class="btn" onclick="game.setTurn(12)">Set Turn 12</button>
    <button class="btn" onclick="game.triggerWinCheck()">Trigger Win Check</button>
    <button class="btn" onclick="game.showGameState()">Show State</button>
  </div>
  
  <div class="debug-section">
    <h4>Player Info</h4>
    <div id="debugAgendas"></div>
  </div>
  
  <div class="debug-section">
    <h4>Breed Powers</h4>
    <button class="btn" onclick="game.testBreedPower()">Test Breed Power</button>
    <button class="btn" onclick="game.cycleBreed()">Change Breed</button>
    <div id="debugBreed" style="margin-top: 10px; font-size: 0.9rem;"></div>
  </div>
  
  <button class="btn" onclick="game.toggleDebugPanel()" style="margin-top: 10px;">Close</button>
</div>

<!-- Setup Modal -->
<div class="target-modal" id="setupModal" style="display: none;">
  <div class="target-title">New Game Setup</div>
  <div style="margin-bottom: 1.5rem;">
    <label style="display: block; margin-bottom: 0.5rem;">Number of Players</label>
    <select id="playerCount" class="btn" style="width: 100%;">
      <option value="2">2 Players</option>
      <option value="3">3 Players</option>
      <option value="4" selected>4 Players</option>
      <option value="5">5 Players</option>
      <option value="6">6 Players</option>
    </select>
  </div>
  <div id="playerSetupFields"></div>
  <button class="btn btn-primary" onclick="game.startNewGame()" style="width: 100%; margin-top: 1rem;">Start Game</button>
</div>

<script>
// 3D Board Manager
class Board3D {
  constructor() {
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.controls = null;
    this.spaces = [];
    this.meeples = [];
    this.cameraMode = 'default';
    this.init();
  }

  init() {
    const container = document.getElementById('canvas3d');
    if (!container) {
      console.error('Canvas3d container not found!');
      return;
    }
    
    // Use fixed width if offsetWidth is 0
    const width = container.offsetWidth || 500;
    const height = 450;
    

    // Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0xfaf0e6);

    // Camera - adjusted to show first spot (position 1)
    this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    // Position 1 is at x=6, z=0, y=0.1
    this.camera.position.set(8, 3, 3);
    this.camera.lookAt(6, 0.1, 0);

    // Renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    this.renderer.setSize(width, height);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.setClearColor(0xfaf0e6, 1);
    container.appendChild(this.renderer.domElement);

    // OrbitControls
    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.maxPolarAngle = Math.PI / 2;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    this.scene.add(directionalLight);

    // Create board
    this.createBoard();
    
    // Animation loop
    this.animate();
  }

  createBoard() {
    const numSpaces = 50;
    const radius = 6;
    
    // Base platform
    const platformGeometry = new THREE.CylinderGeometry(radius + 1, radius + 1, 0.2, 32);
    const platformMaterial = new THREE.MeshPhongMaterial({ color: 0x2a4b8d });
    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
    platform.receiveShadow = true;
    this.scene.add(platform);

    // Create spaces
    for (let i = 0; i < numSpaces; i++) {
      const angle = (i / numSpaces) * Math.PI * 2;
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      const y = (i / numSpaces) * 3 + 0.1; // Spiral upward, slight offset to avoid z-fighting
      
      // Log first position for camera debugging
      if (i === 0) {
        console.log(`Position 1 is at: x=${x}, y=${y}, z=${z}`);
      }

      // Space
      const geometry = new THREE.BoxGeometry(0.6, 0.2, 0.6);
      const material = new THREE.MeshPhongMaterial({
        color: this.getSpaceColor(i + 1)
      });
      const space = new THREE.Mesh(geometry, material);
      space.position.set(x, y, z);
      space.castShadow = true;
      space.receiveShadow = true;
      space.userData = { index: i + 1 };
      
      this.spaces.push(space);
      this.scene.add(space);

      // Number label
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 64;
      canvas.height = 64;
      context.fillStyle = '#ffffff';
      context.font = 'bold 40px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(i + 1, 32, 32);
      
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.set(x, y + 0.5, z);
      sprite.scale.set(0.5, 0.5, 1);
      this.scene.add(sprite);
    }

    // CEO platform
    const ceoGeometry = new THREE.ConeGeometry(1, 1, 4);
    const ceoMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xffd700,
      emissive: 0xffd700,
      emissiveIntensity: 0.2
    });
    const ceoPlatform = new THREE.Mesh(ceoGeometry, ceoMaterial);
    ceoPlatform.position.set(0, 4, 0);
    ceoPlatform.castShadow = true;
    this.scene.add(ceoPlatform);
  }

  getSpaceColor(position) {
    if (position <= 10) return 0x65c3ba; // Teal - Intern
    if (position <= 20) return 0xf4a261; // Yellow - Junior  
    if (position <= 30) return 0xe9c46a; // Pink - Senior
    if (position <= 40) return 0xe76f51; // Coral - Management
    if (position < 50) return 0x2a4b8d; // Navy - Executive
    return 0xffd700; // Gold - CEO
  }

  updateMeeples(players) {
    // Clear old meeples
    this.meeples.forEach(m => this.scene.remove(m));
    this.meeples = [];

    // Group players by position
    const playersByPosition = {};
    players.forEach((player, index) => {
      const pos = Math.min(50, Math.max(1, player.position));
      if (!playersByPosition[pos]) {
        playersByPosition[pos] = [];
      }
      playersByPosition[pos].push({ player, index });
    });
    
    console.log('Players by position:', playersByPosition);
    console.log('Total players:', players.length);
    console.log('Player details:', players.map(p => ({name: p.name, position: p.position})));

    // Add meeples with proper spacing
    Object.entries(playersByPosition).forEach(([position, playersAtPosition]) => {
      const space = this.spaces[position - 1];
      
      if (space) {
        playersAtPosition.forEach((playerData, localIndex) => {
          const { player, index } = playerData;
          const geometry = new THREE.ConeGeometry(0.4, 0.8, 8);
          const material = new THREE.MeshPhongMaterial({
            color: this.getPlayerColor(index),
            emissive: this.getPlayerColor(index),
            emissiveIntensity: 0.3
          });
          const meeple = new THREE.Mesh(geometry, material);
          
          // Only offset if multiple players on same space
          if (playersAtPosition.length > 1) {
            const angle = (localIndex / playersAtPosition.length) * Math.PI * 2;
            const radius = 0.4;  // Increased radius for better visibility
            const offsetX = Math.cos(angle) * radius;
            const offsetZ = Math.sin(angle) * radius;
            meeple.position.set(
              space.position.x + offsetX,
              space.position.y + 0.5,
              space.position.z + offsetZ
            );
            console.log(`Player ${index} at position ${position}, localIndex ${localIndex}, angle ${angle}, offset: (${offsetX}, ${offsetZ})`);
          } else {
            // Single player - center on space
            meeple.position.set(
              space.position.x,
              space.position.y + 0.5,
              space.position.z
            );
          }
          
          meeple.castShadow = true;
          meeple.receiveShadow = true;
          
          this.meeples.push(meeple);
          this.scene.add(meeple);
          console.log(`Added meeple for player ${index} (${player.name}) at final position:`, meeple.position);
        });
      }
    });
  }

  getPlayerColor(index) {
    const colors = [0xe76f51, 0x65c3ba, 0xf4a261, 0xe9c46a, 0x2a4b8d, 0x8b9dc3];
    return colors[index % colors.length];
  }

  setCameraView(mode) {
    this.cameraMode = mode;
    
    switch(mode) {
      case 'top':
        this.camera.position.set(0, 15, 0);
        this.camera.lookAt(0, 0, 0);
        break;
      case 'side':
        this.camera.position.set(12, 5, 0);
        this.camera.lookAt(0, 2, 0);
        break;
      case 'follow':
        if (this.meeples[0]) {
          const leader = this.meeples[0];
          this.camera.position.set(
            leader.position.x + 5,
            leader.position.y + 5,
            leader.position.z + 5
          );
          this.camera.lookAt(leader.position);
        }
        break;
      default:
        this.resetCamera();
    }
  }

  resetCamera() {
    this.camera.position.set(8, 3, 3);
    this.camera.lookAt(6, 0.1, 0);
    this.cameraMode = 'default';
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    
    // Update controls
    this.controls.update();
    
    // Rotate meeples
    this.meeples.forEach(meeple => {
      meeple.rotation.y += 0.02;
    });
    
    // Auto-rotate in follow mode
    if (this.cameraMode === 'follow' && this.meeples[0]) {
      const time = Date.now() * 0.001;
      const radius = 8;
      this.camera.position.x = this.meeples[0].position.x + Math.cos(time) * radius;
      this.camera.position.z = this.meeples[0].position.z + Math.sin(time) * radius;
      this.camera.position.y = this.meeples[0].position.y + 5;
      this.camera.lookAt(this.meeples[0].position);
    }
    
    this.renderer.render(this.scene, this.camera);
  }
}

// Main Game Class
class DogsWithJobsGame {
  constructor() {
    this.board3D = null;
    this.state = {
      players: [],
      currentPlayer: 0,
      firstPlayer: 0,
      turn: 1,
      phase: 'setup',
      round: 1,
      projects: [],
      actionDeck: [],
      distractionDeck: [],
      projectDeck: [],
      winner: null,
      cardsPlayedThisRound: 0,
      bidsThisTurn: []
    };
    
    this.draggedCard = null;
    
    setTimeout(() => {
      this.init();
    }, 100);
  }

  init() {
    this.board3D = new Board3D();
    this.setupEventListeners();
    this.loadDecks();
    this.showSetupModal();
    this.createBreedTooltip();
  }
  
  createBreedTooltip() {
    const tooltip = document.createElement('div');
    tooltip.id = 'breedTooltip';
    tooltip.className = 'tooltip';
    tooltip.style.display = 'none';
    document.body.appendChild(tooltip);
  }
  
  getBreedPowers() {
    return {
      'Golden Retriever': { 
        name: 'Good Boy Energy',
        desc: 'Gain Sympathy tokens when losing bids. Spend 3 = climb 1 space. Can gift cards for tokens.',
        hasTokens: true,
        tokenName: 'Sympathy',
        maxTokens: 5
      },
      'German Shepherd': { 
        name: 'Cop Energy',
        desc: '+1⚡ when bidding on Management projects'
      },
      'Border Collie': { 
        name: 'Workaholic Control',
        desc: 'Draw 6 cards minimum. Gain Focus tokens when winning. Spend 2 = draw a Distraction.',
        hasTokens: true,
        tokenName: 'Focus',
        maxTokens: 5,
        cardMinimum: 6
      },
      'Chihuahua': { 
        name: 'Napoleon Complex',
        desc: 'Win ALL ties. Gain Rage tokens when targeted. Spend 2 = force discard. PENALTY: -1 space per 2 unused tokens.',
        hasTokens: true,
        tokenName: 'Rage',
        maxTokens: 5,
        winsTies: true
      },
      'Labrador': { 
        name: 'Boundless Energy',
        desc: 'Play up to 2 cards per round. Gain Enthusiasm tokens for exact bids. Spend 2 = play 3rd card.',
        hasTokens: true,
        tokenName: 'Enthusiasm',
        maxTokens: 5,
        cardsPerRound: 2
      },
      'Beagle': { 
        name: 'Sniff Out Secrets',
        desc: 'Gain Curiosity tokens when losing bids. Spend 3 = see all bids on one project. Can preview Distraction deck.',
        hasTokens: true,
        tokenName: 'Curiosity',
        maxTokens: 5
      },
      'Husky': { 
        name: 'Independent Spirit',
        desc: '+1 space when winning alone. Immune to pack distractions. Gain Determination tokens on solo bids.',
        hasTokens: true,
        tokenName: 'Determination',
        maxTokens: 5
      },
      'Pug': { 
        name: 'Adorable Incompetence',
        desc: 'Gain 1 space for lowest bid. Gain Charm tokens when gifted to. Spend 2 = force someone to bid.',
        hasTokens: true,
        tokenName: 'Charm',
        maxTokens: 5
      },
      'Dalmatian': { 
        name: 'Firefighter PTSD',
        desc: '+2💪 energy when completing any project'
      },
      'Bloodhound': { 
        name: 'Stalker Instincts',
        desc: 'Can look at any player\'s Hidden Agenda once per game'
      },
      'Great Dane': { 
        name: 'Big Dog Privilege',
        desc: 'Other players need +1 energy to target you with Distractions'
      },
      'Jack Russell': { 
        name: 'Cocaine Energy',
        desc: 'Once per turn, discard 2 cards to draw 3 new ones'
      },
      'Australian Cattle Dog': { 
        name: 'Chaos Coordinator',
        desc: 'Can play up to 2 Instant Distraction Cards per turn, but must discard 1 extra'
      }
    };
  }
  
  showBreedTooltip(event, playerId) {
    const tooltip = document.getElementById('breedTooltip');
    if (!tooltip) return;
    
    const select = event.target;
    const breed = select.value;
    const breedPowers = this.getBreedPowers();
    
    const power = breedPowers[breed];
    if (power) {
      tooltip.innerHTML = `<strong>${breed}: ${power.name}</strong><br>${power.desc}`;
    } else {
      tooltip.innerHTML = `<strong>${breed}</strong><br>Selected breed: ${breed} (checking for power...)`;
      console.log('Breed not found in powers:', breed, 'Available:', Object.keys(breedPowers));
    }
    
    tooltip.style.display = 'block';
    tooltip.style.left = (event.pageX + 10) + 'px';
    tooltip.style.top = (event.pageY + 10) + 'px';
  }
  
  hideBreedTooltip() {
    const tooltip = document.getElementById('breedTooltip');
    if (tooltip) tooltip.style.display = 'none';
  }
  
  toggleGearMenu() {
    const dropdown = document.getElementById('gearDropdown');
    dropdown.classList.toggle('open');
    
    // Close on click outside
    if (dropdown.classList.contains('open')) {
      setTimeout(() => {
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.gear-menu')) {
            dropdown.classList.remove('open');
          }
        }, { once: true });
      }, 100);
    }
  }
  
  showBreedPowerTooltip(event, breed) {
    const tooltip = document.getElementById('breedTooltip');
    if (!tooltip) {
      this.createBreedTooltip();
      return this.showBreedPowerTooltip(event, breed);
    }
    
    const breedPowers = this.getBreedPowers();
    const power = breedPowers[breed];
    
    if (power) {
      tooltip.innerHTML = `<strong>${breed}: ${power.name}</strong><br>${power.desc}`;
    } else {
      tooltip.innerHTML = `<strong>${breed}</strong><br>No special power`;
    }
    
    tooltip.style.display = 'block';
    tooltip.style.left = (event.pageX + 10) + 'px';
    tooltip.style.top = (event.pageY - 30) + 'px';
    tooltip.classList.add('show');
  }
  
  showAgendaTooltip(event, playerIndex) {
    const player = this.state.players[playerIndex];
    if (!player || !player.agenda) return;
    
    const tooltip = document.getElementById('breedTooltip');
    if (!tooltip) {
      this.createBreedTooltip();
      return this.showAgendaTooltip(event, playerIndex);
    }
    
    // Show the agenda's TEXT (requirements) in the tooltip
    const agendaText = player.agenda?.text || 'Unknown requirements';
    tooltip.innerHTML = `<strong>Requirements:</strong><br>${agendaText}`;
    tooltip.style.display = 'block';
    tooltip.style.left = (event.pageX + 10) + 'px';
    tooltip.style.top = (event.pageY - 30) + 'px';
    tooltip.classList.add('show');
  }

  setupEventListeners() {
    document.getElementById('playerCount').addEventListener('change', (e) => {
      this.updatePlayerSetupFields(e.target.value);
    });

    // Global drag events
    document.addEventListener('dragover', (e) => e.preventDefault());
    document.addEventListener('drop', (e) => e.preventDefault());
  }

  showNotification(title, message, duration = 2500) {
    const notification = document.getElementById('notification');
    document.getElementById('notificationTitle').textContent = title;
    document.getElementById('notificationMessage').textContent = message;
    notification.classList.add('show');
    
    setTimeout(() => {
      notification.classList.remove('show');
    }, duration);
  }

  setCameraView(mode) {
    if (this.board3D) {
      this.board3D.setCameraView(mode);
    }
  }

  resetCamera() {
    if (this.board3D) {
      this.board3D.resetCamera();
    }
  }

  loadDecks() {
    this.state.actionDeck = this.generateActionDeck();
    this.state.distractionDeck = this.generateDistractionDeck();
    this.state.projectDeck = this.generateProjectDeck();
  }

  generateActionDeck() {
    const actions = {
      communication: [
        { name: "Bark", energy: { comm: 2 }, count: 3 },
        { name: "Howl at moon", energy: { comm: 2, focus: 1 }, count: 2 },
        { name: "Whimper", energy: { comm: 1 }, count: 2 },
        { name: "Growl at Jeff from Accounting", energy: { comm: 2, phys: 1 }, count: 1 },
        { name: "Excited yipping", energy: { comm: 1, social: 1 }, count: 2 },
        { name: "Aggressive throat singing", energy: { comm: 3 }, count: 1 },
        { name: "Woof of confusion", energy: { comm: 1 }, count: 2 },
        { name: "Bark at absolutely nothing for 20 minutes", energy: { comm: 3 }, count: 1 },
        { name: "Howl about your divorce", energy: { comm: 2, focus: 1 }, count: 1 },
        { name: "Whine about office temperature", energy: { comm: 1, social: 1 }, count: 1 },
        { name: "Death metal growl", energy: { comm: 2, phys: 1 }, count: 1 },
        { name: "Existential howling", energy: { comm: 2, focus: 2 }, count: 1 },
        { name: "Complain to HR via interpretive barking", energy: { comm: 3, social: 1 }, count: 1 },
        { name: "Whisper menacingly", energy: { comm: 1, focus: 1 }, count: 1 }
      ],
      focus: [
        { name: "Sit", energy: { focus: 1 }, count: 3 },
        { name: "Stay", energy: { focus: 2 }, count: 2 },
        { name: "Stare at wall", energy: { focus: 2 }, count: 2 },
        { name: "Scratch ear", energy: { focus: 1 }, count: 2 },
        { name: "Tilt head", energy: { focus: 1 }, count: 2 },
        { name: "Zone out completely", energy: { focus: 3 }, count: 1 },
        { name: "Enter dissociative state", energy: { focus: 3 }, count: 1 },
        { name: "Contemplate mortality", energy: { focus: 2, comm: 1 }, count: 1 },
        { name: "Meditate on the futility of corporate life", energy: { focus: 4 }, count: 1 },
        { name: "See ghosts", energy: { focus: 2, social: 1 }, count: 1 },
        { name: "Calculate exact distance to treat drawer", energy: { focus: 2, phys: 1 }, count: 1 },
        { name: "Judge everyone silently", energy: { focus: 2 }, count: 1 },
        { name: "Achieve enlightenment briefly", energy: { focus: 3, social: 1 }, count: 1 },
        { name: "Laser focus on dust mote", energy: { focus: 1, phys: 1 }, count: 1 }
      ],
      social: [
        { name: "Wag tail", energy: { social: 1 }, count: 3 },
        { name: "Roll over", energy: { social: 1 }, count: 2 },
        { name: "Play bow", energy: { social: 2 }, count: 2 },
        { name: "Puppy eyes", energy: { social: 1, comm: 1 }, count: 2 },
        { name: "Happy dance", energy: { social: 1, phys: 1 }, count: 2 },
        { name: "Aggressive snuggling", energy: { social: 2, phys: 1 }, count: 1 },
        { name: "Weaponized cuteness", energy: { social: 3 }, count: 1 },
        { name: "Manipulative head tilt", energy: { social: 2, focus: 1 }, count: 1 },
        { name: "Emotional support presence", energy: { social: 2 }, count: 1 },
        { name: "Unconditional love bombing", energy: { social: 3, comm: 1 }, count: 1 },
        { name: "Codependent behavior", energy: { social: 2, comm: 1 }, count: 1 },
        { name: "People pleasing to unhealthy degree", energy: { social: 2, focus: 2 }, count: 1 },
        { name: "Guilt trip via eye contact", energy: { social: 1, comm: 2 }, count: 1 }
      ],
      physical: [
        { name: "Run", energy: { phys: 2 }, count: 3 },
        { name: "Dig", energy: { phys: 2 }, count: 2 },
        { name: "Fetch", energy: { phys: 1, social: 1 }, count: 2 },
        { name: "Shake", energy: { phys: 1 }, count: 2 },
        { name: "Paw at air", energy: { phys: 1 }, count: 2 },
        { name: "Zoomies", energy: { phys: 3 }, count: 1 },
        { name: "Violent full-body shake", energy: { phys: 2, comm: 1 }, count: 1 },
        { name: "Excavate to Australia", energy: { phys: 3 }, count: 1 },
        { name: "Parkour through cubicles", energy: { phys: 2, focus: 1 }, count: 1 },
        { name: "Stress digging in conference room", energy: { phys: 2, comm: 1 }, count: 1 },
        { name: "Fetch nothing with passion", energy: { phys: 2, social: 1 }, count: 1 },
        { name: "Territorial leg lifting", energy: { phys: 2, comm: 2 }, count: 1 },
        { name: "Interpretive dance about quarterly reports", energy: { phys: 1, social: 2 }, count: 1 }
      ]
    };

    const deck = [];
    for (const [category, cards] of Object.entries(actions)) {
      for (const card of cards) {
        for (let i = 0; i < card.count; i++) {
          deck.push({
            id: `action_${deck.length}`,
            name: card.name,
            energy: { comm: 0, focus: 0, social: 0, phys: 0, ...card.energy },
            category: category
          });
        }
      }
    }

    return this.shuffle(deck);
  }

  generateDistractionDeck() {
    const distractions = {
      instant: [
        { name: "Squirrel!", effect: "Target must immediately reveal and discard 1 face-down bid card", count: 4, type: 'instant', targetRequired: true },
        { name: "Doorbell", effect: "Target cannot play any cards in the next bidding round", count: 3, type: 'instant', targetRequired: true },
        { name: "Sudden play fight", effect: "Swap hands with target player immediately", count: 2, type: 'instant', targetRequired: true },
        { name: "Zoomies attack", effect: "Target must shuffle all their face-down bid cards back into hand, cannot bid on any projects this turn", count: 2, type: 'instant', targetRequired: true },
        { name: "Treat emergency", effect: "Target must discard 1 card from hand before their next bidding round", count: 2, type: 'instant', targetRequired: true },
        { name: "Mailman spotted at 3 o'clock", effect: "All Communication energy gets +1 bonus for remainder of this bidding phase", count: 1, type: 'instant', targetRequired: false },
        { name: "Existential crisis", effect: "Target must explain their final bid in character as a dog during reveal", count: 1, type: 'instant', targetRequired: true }
      ],
      endOfTurn: [
        { name: "Pack mentality activated", effect: "Everyone passes 1 card clockwise", count: 3, type: 'end', targetRequired: false },
        { name: "Management restructure", effect: "Shuffle current projects away, draw new ones", count: 2, type: 'end', targetRequired: false },
        { name: "Office gossip network", effect: "Look at target player's Hidden Agenda card", count: 2, type: 'end', targetRequired: true },
        { name: "Mandatory team lunch", effect: "Everyone draws 2 cards, discards 1", count: 2, type: 'end', targetRequired: false },
        { name: "IT disaster recovery", effect: "Everyone discards entire hand, draws back to minimum", count: 1, type: 'end', targetRequired: false },
        { name: "Coffee machine breakdown", effect: "Target player cannot play Instant Distractions next turn", count: 2, type: 'end', targetRequired: true },
        { name: "Participation trophy distribution", effect: "All players who didn't win a project this turn draw 1 extra card", count: 2, type: 'end', targetRequired: false },
        { name: "Fire drill chaos", effect: "Next turn, all bid cards must be played face-up instead of face-down", count: 1, type: 'end', targetRequired: false }
      ],
      beneficial: [
        { name: "Coffee delivery", effect: "You and target player both draw 1 card immediately", count: 2, type: 'instant', beneficial: true, targetRequired: true },
        { name: "Motivational speech", effect: "All players get +1 energy to their next bid this turn", count: 1, type: 'instant', beneficial: true, targetRequired: false },
        { name: "Lucky break", effect: "Look at the top 3 Project Cards, choose which ones to reveal", count: 1, type: 'instant', beneficial: true, targetRequired: false },
        { name: "Team bonding exercise", effect: "All players draw 1 extra card, you draw 2 extra", count: 2, type: 'end', beneficial: true, targetRequired: false },
        { name: "Performance bonus", effect: "If you completed a project this turn, move up 1 additional space", count: 1, type: 'end', beneficial: true, targetRequired: false },
        { name: "Mentorship program", effect: "Choose another player; both of you gain +1 energy to all bids next turn", count: 1, type: 'end', beneficial: true, targetRequired: true }
      ]
    };

    const deck = [];
    for (const [category, cards] of Object.entries(distractions)) {
      for (const card of cards) {
        for (let i = 0; i < card.count; i++) {
          deck.push({
            id: `distraction_${deck.length}`,
            name: card.name,
            type: card.type,
            effect: card.effect,
            targetRequired: card.targetRequired,
            beneficial: card.beneficial || false,
            category: category
          });
        }
      }
    }

    return this.shuffle(deck);
  }

  generateProjectDeck() {
    const projects = {
      entry: [
        { name: "File paperwork", cost: { focus: 2 }, tier: 'Entry', spaces: 1 },
        { name: "Answer phones", cost: { comm: 2 }, tier: 'Entry', spaces: 1 },
        { name: "Greet visitors", cost: { social: 1, comm: 1 }, tier: 'Entry', spaces: 1 },
        { name: "Data entry", cost: { focus: 3 }, tier: 'Entry', spaces: 1 },
        { name: "Coffee run", cost: { phys: 2 }, tier: 'Entry', spaces: 1 },
        { name: "Sort mail", cost: { phys: 1, focus: 1 }, tier: 'Entry', spaces: 1 },
        { name: "Water plants", cost: { phys: 1 }, tier: 'Entry', spaces: 1 },
        { name: "Organize supplies", cost: { phys: 2 }, tier: 'Entry', spaces: 1 },
        { name: "Update database without paw prints on keyboard", cost: { focus: 2, phys: 1 }, tier: 'Entry', spaces: 1 },
        { name: "Professional email (no 'woof' in signature)", cost: { comm: 2, focus: 1 }, tier: 'Entry', spaces: 1 },
        { name: "Schedule meetings during optimal nap hours", cost: { comm: 1, focus: 2 }, tier: 'Entry', spaces: 1 },
        { name: "Inventory without hiding treats", cost: { focus: 2, phys: 1 }, tier: 'Entry', spaces: 1 },
        { name: "Client small talk without sniffing", cost: { comm: 1, social: 1 }, tier: 'Entry', spaces: 1 },
        { name: "Photocopy without eating paper", cost: { phys: 1, focus: 1 }, tier: 'Entry', spaces: 1 },
        { name: "Reception desk: no leg humping", cost: { social: 2 }, tier: 'Entry', spaces: 1 }
      ],
      management: [
        { name: "Lead team meeting", cost: { comm: 2, social: 1 }, tier: 'Management', spaces: 2 },
        { name: "Budget review", cost: { focus: 3 }, tier: 'Management', spaces: 2 },
        { name: "Performance evaluations", cost: { social: 2, focus: 1 }, tier: 'Management', spaces: 2 },
        { name: "Strategic planning", cost: { focus: 3, comm: 1 }, tier: 'Management', spaces: 2 },
        { name: "Client presentation", cost: { comm: 3 }, tier: 'Management', spaces: 2 },
        { name: "Contract negotiation", cost: { comm: 2, phys: 1 }, tier: 'Management', spaces: 2 },
        { name: "Crisis management", cost: { phys: 2, comm: 1 }, tier: 'Management', spaces: 2 },
        { name: "Staff training", cost: { social: 2, comm: 1 }, tier: 'Management', spaces: 2 },
        { name: "Market research", cost: { focus: 2, phys: 1 }, tier: 'Management', spaces: 2 },
        { name: "Quality control", cost: { focus: 2, phys: 1 }, tier: 'Management', spaces: 2 },
        { name: "Vendor relations", cost: { comm: 2, social: 1 }, tier: 'Management', spaces: 2 },
        { name: "Process improvement", cost: { focus: 2, phys: 1 }, tier: 'Management', spaces: 2 },
        { name: "Team building without inappropriate mounting", cost: { social: 3, comm: 1 }, tier: 'Management', spaces: 2 },
        { name: "Disciplinary meeting (no growling)", cost: { comm: 2, focus: 2 }, tier: 'Management', spaces: 2 },
        { name: "Quarterly projections beyond 'treats = good'", cost: { focus: 4 }, tier: 'Management', spaces: 2 }
      ],
      executive: [
        { name: "Board presentation without humping anyone's leg", cost: { comm: 4, focus: 1 }, tier: 'Executive', spaces: 3 },
        { name: "Merger negotiation (no territorial marking)", cost: { comm: 3, social: 2 }, tier: 'Executive', spaces: 3 },
        { name: "Company restructure that isn't just pack hierarchy", cost: { focus: 3, phys: 2 }, tier: 'Executive', spaces: 3 },
        { name: "Annual strategy beyond 'acquire all treats'", cost: { focus: 4, social: 1 }, tier: 'Executive', spaces: 3 },
        { name: "IPO preparation (Initial Puppy Offering)", cost: { comm: 3, focus: 2 }, tier: 'Executive', spaces: 3 },
        { name: "Hostile takeover via aggressive tail wagging", cost: { comm: 2, phys: 2, social: 1 }, tier: 'Executive', spaces: 3 }
      ]
    };

    const deck = [];
    for (const [tier, cards] of Object.entries(projects)) {
      for (const card of cards) {
        deck.push({
          id: `project_${deck.length}`,
          name: card.name,
          tier: card.tier,
          cost: { comm: 0, focus: 0, social: 0, phys: 0, ...card.cost },
          reward: card.spaces
        });
      }
    }

    return this.shuffle(deck);
  }

  shuffle(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  showSetupModal() {
    document.getElementById('setupModal').style.display = 'block';
    this.updatePlayerSetupFields(4);
  }

  updatePlayerSetupFields(count) {
    const container = document.getElementById('playerSetupFields');
    container.innerHTML = '';
    
    const breeds = [
      'Golden Retriever', 'German Shepherd', 'Border Collie', 'Chihuahua',
      'Labrador', 'Beagle', 'Husky', 'Pug', 'Dalmatian', 'Bloodhound',
      'Great Dane', 'Jack Russell', 'Australian Cattle Dog'
    ];
    
    const breedPowers = this.getBreedPowers();
    
    for (let i = 0; i < count; i++) {
      const field = document.createElement('div');
      field.style.marginBottom = '1rem';
      field.innerHTML = `
        <label style="display: block; margin-bottom: 0.5rem;">Player ${i + 1}</label>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
          <input type="text" class="btn" id="player${i}Name" value="Player ${i + 1}" style="padding: 0.5rem;">
          <select class="btn breed-select" id="player${i}Breed" style="padding: 0.5rem;" onmouseover="game.showBreedTooltip(event, '${i}')" onmouseout="game.hideBreedTooltip()">
            ${breeds.map(b => `<option value="${b}">${b}</option>`).join('')}
          </select>
        </div>
      `;
      container.appendChild(field);
    }
  }

  startNewGame() {
    const count = parseInt(document.getElementById('playerCount').value);
    
    // Create players
    this.state.players = [];
    for (let i = 0; i < count; i++) {
      const name = document.getElementById(`player${i}Name`).value;
      const breed = document.getElementById(`player${i}Breed`).value;
      
      this.state.players.push({
        id: `player_${i}`,
        name: name,
        breed: breed,
        position: 1,
        handAction: [],
        handDistraction: [],
        bids: [[], [], []],
        agenda: this.getRandomAgenda(),
        // Tracking for win conditions
        completedProjects: [],
        distractionsPlayed: 0,
        distractionsReceived: 0,
        positionHistory: [1],
        lastTurnPosition: 1,
        // Breed-specific tracking
        usedBreedPower: false,  // For once-per-game/turn powers
        bonusEnergy: { comm: 0, focus: 0, social: 0, phys: 0 },  // For breed bonuses
        // v2.0: Token system
        breedTokens: 0,  // Number of breed-specific tokens
        maxTokens: 5     // Maximum tokens player can hold
      });
    }
    
    // Apply initial breed setup (v2.0)
    this.state.players.forEach(player => {
      const power = this.getBreedPowers()[player.breed];
      if (power && power.hasTokens) {
        player.maxTokens = power.maxTokens || 5;
        player.tokenName = power.tokenName || 'Breed';
      }
      
      // Border Collie gets 6 card minimum
      if (player.breed === 'Border Collie') {
        player.cardMinimum = 6;
      } else {
        player.cardMinimum = 5;
      }
    });
    
    // Deal initial cards
    this.dealInitialCards();
    
    // Setup projects
    this.state.projects = [];
    for (let i = 0; i < 3; i++) {
      if (this.state.projectDeck.length > 0) {
        this.state.projects.push(this.state.projectDeck.shift());
      }
    }
    
    this.state.phase = 'bidding';
    this.state.currentPlayer = 0;
    this.state.firstPlayer = 0;
    
    document.getElementById('setupModal').style.display = 'none';
    this.render();
    this.updateHeaderStatus();
    this.showNotification('Game Started!', 'Good luck climbing the corporate ladder!');
  }

  dealInitialCards() {
    this.state.players.forEach(player => {
      // Use player's card minimum (v2.0)
      const cardCount = player.cardMinimum || 5;
      
      for (let i = 0; i < cardCount; i++) {
        if (this.state.actionDeck.length > 0) {
          player.handAction.push(this.state.actionDeck.shift());
        }
      }
      
      // Beagle draws 2 distraction cards and keeps 1
      if (player.breed === 'Beagle') {
        const distractionOptions = [];
        for (let i = 0; i < 2 && this.state.distractionDeck.length > 0; i++) {
          distractionOptions.push(this.state.distractionDeck.shift());
        }
        if (distractionOptions.length > 0) {
          // For now, auto-select the first one (could add UI for choice later)
          player.handDistraction.push(distractionOptions[0]);
          // Return the other to the deck
          if (distractionOptions[1]) {
            this.state.distractionDeck.push(distractionOptions[1]);
          }
        }
      } else if (this.state.distractionDeck.length > 0) {
        player.handDistraction.push(this.state.distractionDeck.shift());
      }
    });
  }

  render() {
    this.renderProjects();
    this.renderHand();
    this.renderPlayers();
    this.renderDistractions();
    this.renderStatus();
    this.renderLeaderboard();
    this.updateHeaderStatus();
    
    if (this.board3D) {
      this.board3D.updateMeeples(this.state.players);
    }
  }

  renderLeaderboard() {
    const compact = document.getElementById('compactLeaderboard');
    if (!compact) return;
    
    const sortedPlayers = [...this.state.players].sort((a, b) => b.position - a.position);
    
    compact.innerHTML = sortedPlayers.map((player, idx) => `
      <div class="leaderboard-chip" style="background: ${idx === 0 ? 'var(--gradient-coral)' : idx === 1 ? 'var(--gradient-teal)' : 'var(--gradient-navy)'}; color: white; padding: 0.5rem 1rem; border-radius: 20px; display: inline-flex; align-items: center; gap: 0.5rem; font-weight: 600; box-shadow: var(--shadow-md);">
        <span style="font-size: 0.9rem;">${idx === 0 ? '👑' : idx === 1 ? '🥈' : idx === 2 ? '🥉' : `#${idx + 1}`}</span>
        <span>${player.name}</span>
        <span style="opacity: 0.9; font-size: 0.85rem;">Lvl ${player.position}</span>
      </div>
    `).join('');
  }

  renderProjects() {
    const grid = document.getElementById('projectsGrid');
    grid.innerHTML = '';
    
    this.state.projects.forEach((project, index) => {
      if (!project) return;
      
      const card = document.createElement('div');
      card.className = 'project-card';
      card.dataset.index = index;
      
      // Drop target
      card.addEventListener('dragover', (e) => {
        e.preventDefault();
        card.classList.add('drag-over');
      });
      
      card.addEventListener('dragleave', () => {
        card.classList.remove('drag-over');
      });
      
      card.addEventListener('drop', (e) => {
        e.preventDefault();
        card.classList.remove('drag-over');
        this.handleCardDrop(index);
      });
      
      const tier = document.createElement('div');
      tier.className = 'project-tier';
      tier.textContent = project.tier;
      
      const name = document.createElement('div');
      name.className = 'project-name';
      name.textContent = project.name;
      
      const cost = document.createElement('div');
      cost.className = 'project-cost';
      
      ['comm', 'focus', 'social', 'phys'].forEach(type => {
        if (project.cost[type] > 0) {
          for (let i = 0; i < project.cost[type]; i++) {
            const badge = document.createElement('div');
            badge.className = 'energy-badge';
            badge.textContent = this.getEnergyEmoji(type);
            cost.appendChild(badge);
          }
        }
      });
      
      // Bid indicators
      const bids = document.createElement('div');
      bids.className = 'bid-indicators';
      
      this.state.players.forEach((player, playerIndex) => {
        player.bids[index].forEach(() => {
          const chip = document.createElement('div');
          chip.className = 'bid-chip';
          chip.style.background = this.getPlayerColorHex(playerIndex);
          chip.textContent = player.name.charAt(0);
          bids.appendChild(chip);
        });
      });
      
      card.appendChild(tier);
      card.appendChild(name);
      card.appendChild(cost);
      card.appendChild(bids);
      
      grid.appendChild(card);
    });
  }

  renderHand() {
    const container = document.getElementById('handContainer');
    container.innerHTML = '';
    
    const currentPlayer = this.state.players[this.state.currentPlayer];
    if (!currentPlayer) return;
    
    // Display breed power at top of hand
    const breedInfo = document.createElement('div');
    breedInfo.style.cssText = 'padding: 10px; background: var(--gradient-teal); color: white; border-radius: 8px; margin-bottom: 10px; text-align: center;';
    const powers = this.getBreedPowers();
    const power = powers[currentPlayer.breed];
    if (power) {
      breedInfo.innerHTML = `<strong>${currentPlayer.breed}</strong>: ${power.name} - ${power.desc}`;
      
      // Add special breed power buttons
      if (currentPlayer.breed === 'Pug' && !currentPlayer.usedBreedPower) {
        const stealBtn = document.createElement('button');
        stealBtn.className = 'btn';
        stealBtn.style.cssText = 'margin-left: 10px; padding: 5px 10px; background: #E76F51;';
        stealBtn.textContent = 'Use Breathing Problems (Steal Project)';
        stealBtn.onclick = () => this.usePugPower(currentPlayer);
        breedInfo.appendChild(stealBtn);
      }
      
      if (currentPlayer.breed === 'Jack Russell') {
        const cycleBtn = document.createElement('button');
        cycleBtn.className = 'btn';
        cycleBtn.style.cssText = 'margin-left: 10px; padding: 5px 10px; background: #F4A261;';
        cycleBtn.textContent = 'Use Cocaine Energy (Discard 2 Draw 3)';
        cycleBtn.onclick = () => this.useJackRussellPower(currentPlayer);
        breedInfo.appendChild(cycleBtn);
      }
      
      if (currentPlayer.breed === 'Bloodhound' && !currentPlayer.usedBreedPower) {
        const peekBtn = document.createElement('button');
        peekBtn.className = 'btn';
        peekBtn.style.cssText = 'margin-left: 10px; padding: 5px 10px; background: #65C3BA;';
        peekBtn.textContent = 'Use Stalker Instincts (Peek Agenda)';
        peekBtn.onclick = () => this.useBloodhoundPower(currentPlayer);
        breedInfo.appendChild(peekBtn);
      }
    } else {
      breedInfo.innerHTML = `<strong>${currentPlayer.breed}</strong>`;
    }
    container.appendChild(breedInfo);
    
    currentPlayer.handAction.forEach(card => {
      const cardEl = document.createElement('div');
      cardEl.className = 'action-card';
      cardEl.draggable = true;
      
      cardEl.addEventListener('dragstart', (e) => {
        this.draggedCard = card;
        cardEl.classList.add('dragging');
      });
      
      cardEl.addEventListener('dragend', () => {
        cardEl.classList.remove('dragging');
        this.draggedCard = null;
      });
      
      const name = document.createElement('div');
      name.className = 'card-name';
      name.textContent = card.name;
      
      const energy = document.createElement('div');
      energy.className = 'card-energy';
      
      ['comm', 'focus', 'social', 'phys'].forEach(type => {
        if (card.energy[type] > 0) {
          for (let i = 0; i < card.energy[type]; i++) {
            const span = document.createElement('span');
            span.textContent = this.getEnergyEmoji(type);
            energy.appendChild(span);
          }
        }
      });
      
      cardEl.appendChild(name);
      cardEl.appendChild(energy);
      container.appendChild(cardEl);
    });
  }

  handleCardDrop(projectIndex) {
    if (!this.draggedCard) return;
    
    const currentPlayer = this.state.players[this.state.currentPlayer];
    const maxCards = currentPlayer.breed === 'Labrador' ? 2 : 1;
    
    if (this.state.cardsPlayedThisRound >= maxCards) {
      this.showNotification('Limit Reached', `Maximum ${maxCards} card(s) per round!`);
      return;
    }
    
    // Place bid
    currentPlayer.bids[projectIndex].push(this.draggedCard);
    currentPlayer.handAction = currentPlayer.handAction.filter(c => c.id !== this.draggedCard.id);
    
    this.state.cardsPlayedThisRound++;
    this.state.bidsThisTurn.push({
      player: this.state.currentPlayer,
      project: projectIndex,
      card: this.draggedCard
    });
    
    this.draggedCard = null;
    this.render();
    
    // Auto-end if max cards played
    if (this.state.cardsPlayedThisRound >= maxCards) {
      setTimeout(() => {
        this.showNotification('Turn Complete', `${currentPlayer.name} has played ${maxCards} card(s)`);
        setTimeout(() => this.endBidding(), 1500);
      }, 500);
    }
  }

  renderPlayers() {
    const container = document.getElementById('playersSidebar');
    container.innerHTML = '';
    
    // Get rankings
    const sortedPlayers = [...this.state.players].sort((a, b) => b.position - a.position);
    const rankings = {};
    sortedPlayers.forEach((p, idx) => {
      rankings[p.id] = idx + 1;
    });
    
    this.state.players.forEach((player, index) => {
      const card = document.createElement('div');
      card.className = 'player-card';
      
      // Add player color background
      const playerColor = this.getPlayerColorHex(index);
      card.style.background = `linear-gradient(135deg, ${playerColor}22, ${playerColor}11)`;
      card.style.borderColor = playerColor;
      
      if (index === this.state.currentPlayer) {
        card.classList.add('active');
      }
      
      // Add ranking badge
      const rankBadge = document.createElement('div');
      rankBadge.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: ${playerColor};
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 0.9rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      `;
      rankBadge.textContent = rankings[player.id];
      
      const header = document.createElement('div');
      header.className = 'player-header';
      
      const avatar = document.createElement('div');
      avatar.className = 'player-avatar';
      avatar.style.background = `linear-gradient(135deg, ${playerColor}, ${playerColor}dd)`;
      avatar.textContent = '🐕';
      
      const info = document.createElement('div');
      info.className = 'player-info';
      info.innerHTML = `
        <div class="player-name">${player.name}</div>
        <div class="player-breed breed-info" onmouseover="game.showBreedPowerTooltip(event, '${player.breed}')" onmouseout="game.hideBreedTooltip()" style="cursor: help; text-decoration: underline dotted;">${player.breed}</div>
      `;
      
      header.appendChild(avatar);
      header.appendChild(info);
      
      // Hidden agenda - fixed to show name with tooltip for requirements
      const agenda = document.createElement('div');
      agenda.className = 'hidden-agenda';
      if (index === this.state.currentPlayer) {
        // Show agenda NAME for current player, tooltip shows requirements
        agenda.innerHTML = `
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <strong>🎯 Secret Agenda:</strong>
            <span style="cursor: help; text-decoration: underline dotted;" onmouseover="game.showAgendaTooltip(event, ${index})" onmouseout="game.hideBreedTooltip()">
              ${player.agenda.name}
            </span>
          </div>`;
      } else {
        // Hidden for other players
        agenda.classList.add('concealed');
        agenda.innerHTML = `<strong>🎯 Secret Agenda:</strong> Hidden`;
      }
      
      // v2.0: Add breed token display
      const power = this.getBreedPowers()[player.breed];
      if (power && power.hasTokens) {
        const tokenDisplay = document.createElement('div');
        tokenDisplay.style.cssText = 'margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.5); border-radius: 8px;';
        tokenDisplay.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <strong>${power.tokenName} Tokens:</strong>
            <div style="display: flex; gap: 4px;">
              ${Array(player.maxTokens).fill(0).map((_, i) => 
                `<div style="width: 20px; height: 20px; border-radius: 50%; background: ${i < player.breedTokens ? playerColor : '#ddd'}; border: 2px solid ${playerColor};"></div>`
              ).join('')}
              <span style="margin-left: 8px; font-weight: bold;">${player.breedTokens}/${player.maxTokens}</span>
            </div>
          </div>
        `;
        card.appendChild(tokenDisplay);
      }
      
      card.appendChild(rankBadge);
      card.appendChild(header);
      card.appendChild(agenda);
      container.appendChild(card);
    });
  }

  renderDistractions() {
    const container = document.getElementById('distractionPanel');
    container.innerHTML = '';
    
    this.state.players.forEach(player => {
      player.handDistraction.forEach(card => {
        const miniCard = document.createElement('div');
        miniCard.className = 'distraction-card';
        
        // Card back
        const cardBack = document.createElement('div');
        cardBack.className = 'card-back';
        cardBack.innerHTML = `
          <div class="card-owner">${player.name}</div>
          <div class="card-icon">🎭</div>
        `;
        
        // Card content (hover)
        const cardContent = document.createElement('div');
        cardContent.className = 'card-content';
        cardContent.innerHTML = `
          <div style="font-weight: 700; font-size: 0.7rem; color: white;">${card.name}</div>
          <div style="font-size: 0.6rem; color: white; margin-top: 0.5rem;">${card.effect}</div>
        `;
        
        miniCard.appendChild(cardBack);
        miniCard.appendChild(cardContent);
        
        miniCard.addEventListener('click', () => {
          this.playDistraction(card, player);
        });
        
        container.appendChild(miniCard);
      });
    });
  }

  updateHeaderStatus() {
    // Update header displays
    const turnDisplay = document.getElementById('turnDisplay');
    const phaseDisplay = document.getElementById('phaseDisplay');
    const leaderDisplay = document.getElementById('leaderDisplay');
    
    if (turnDisplay) turnDisplay.textContent = this.state.turn || '1';
    if (phaseDisplay) {
      const phaseText = this.state.phase === 'bidding' ? `Bidding (R${this.state.round})` : 
                       this.state.phase === 'distraction' ? 'Distraction' : 
                       this.state.phase === 'setup' ? 'Setup' : 'Cleanup';
      phaseDisplay.textContent = phaseText;
    }
    if (leaderDisplay && this.state.players.length > 0) {
      const leader = [...this.state.players].sort((a, b) => b.position - a.position)[0];
      leaderDisplay.textContent = leader ? leader.name : '-';
    }
  }

  renderStatus() {
    // Update header displays (not duplicates) 
    const turnEls = document.querySelectorAll('#turnDisplay');
    const phaseEls = document.querySelectorAll('#phaseDisplay');
    const leaderEls = document.querySelectorAll('#leaderDisplay');
    
    turnEls.forEach(el => el.textContent = this.state.turn);
    phaseEls.forEach(el => el.textContent = this.state.phase.toUpperCase());
    leaderEls.forEach(el => el.textContent = this.state.players[this.state.firstPlayer]?.name || '-');
    
    // Update round number if it exists
    const roundNum = document.getElementById('roundNum');
    if (roundNum) roundNum.textContent = this.state.round;
    
    const currentPlayer = this.state.players[this.state.currentPlayer];
    if (currentPlayer) {
      const playerNameEl = document.getElementById('currentPlayerName');
      if (playerNameEl) playerNameEl.textContent = currentPlayer.name;
      
      const cardsIndicator = document.getElementById('cardsIndicator');
      if (cardsIndicator) {
        const maxCards = currentPlayer.breed === 'Labrador' ? 2 : 1;
        cardsIndicator.textContent = `Cards Played: ${this.state.cardsPlayedThisRound}/${maxCards}`;
      }
    }
    
    // Show/hide buttons
    const bidBtn = document.getElementById('endBiddingBtn');
    const distBtn = document.getElementById('endDistractionBtn');
    
    bidBtn.style.display = this.state.phase === 'bidding' ? 'block' : 'none';
    distBtn.style.display = this.state.phase === 'distraction' ? 'block' : 'none';
  }

  endBidding() {
    this.state.cardsPlayedThisRound = 0;
    this.state.currentPlayer = (this.state.currentPlayer + 1) % this.state.players.length;
    
    if (this.state.currentPlayer === this.state.firstPlayer) {
      this.state.round++;
      
      if (this.state.round > 3) {
        this.resolveProjects();
      } else {
        this.showNotification('New Round', `Round ${this.state.round} begins!`);
      }
    }
    
    this.render();
  }

  resolveProjects() {
    // Track who won projects this turn (for Participation Trophy)
    const turnWinners = new Set();
    
    this.state.projects.forEach((project, index) => {
      if (!project) return;
      
      const bids = [];
      this.state.players.forEach(player => {
        // Only count if player actually bid
        if (player.bids[index].length === 0) return;
        
        const energy = { comm: 0, focus: 0, social: 0, phys: 0 };
        player.bids[index].forEach(card => {
          Object.keys(energy).forEach(type => {
            energy[type] += card.energy[type] || 0;
          });
        });
        
        // Apply breed bonuses
        if (player.breed === 'German Shepherd' && project.tier === 'Management') {
          energy.focus += 1;  // +1⚡ for Management projects
        }
        if (player.breed === 'Dalmatian') {
          energy.phys += 2;  // +2💪 for all projects
        }
        
        const totalEnergy = Object.values(energy).reduce((sum, val) => sum + val, 0);
        bids.push({ player, energy, totalEnergy, bidCount: player.bids[index].length });
      });
      
      if (bids.length === 0) return; // No one bid on this project
      
      // Find winner (considering Chihuahua ties)
      const qualified = bids.filter(bid => this.meetsRequirement(bid.energy, project.cost));
      let winner = null;
      let losingBidders = [];
      
      if (qualified.length > 0) {
        // Sort by total energy
        qualified.sort((a, b) => b.totalEnergy - a.totalEnergy);
        
        // Check for ties
        const topEnergy = qualified[0].totalEnergy;
        const tied = qualified.filter(bid => bid.totalEnergy === topEnergy);
        
        if (tied.length > 1) {
          // Check if any Chihuahua in the tie
          const chihuahua = tied.find(bid => bid.player.breed === 'Chihuahua');
          winner = chihuahua ? chihuahua.player : tied[0].player;
        } else {
          winner = qualified[0].player;
        }
        
        // Everyone who bid but didn't win
        losingBidders = bids.filter(bid => bid.player !== winner).map(bid => bid.player);
        
        // Track position before move for Comeback Kid agenda
        winner.lastTurnPosition = winner.position;
        
        // Move up ladder
        winner.position += project.reward;
        
        // v2.0: Breed token gains for winners
        const winnerBid = bids.find(b => b.player === winner);
        const exactMatch = this.isExactEnergyMatch(winnerBid.energy, project.cost);
        
        // Border Collie: gains Focus token on win
        if (winner.breed === 'Border Collie' && winner.breedTokens < winner.maxTokens) {
          winner.breedTokens++;
          this.showNotification('Focus Token', `${winner.name} gained a Focus token!`);
        }
        
        // Labrador: gains Enthusiasm token for exact energy match
        if (winner.breed === 'Labrador' && exactMatch && winner.breedTokens < winner.maxTokens) {
          winner.breedTokens++;
          this.showNotification('Enthusiasm Token', `${winner.name} gained an Enthusiasm token for exact bid!`);
        }
        
        // Track exact matches for The Perfectionist agenda
        if (exactMatch) {
          winner.exactMatches = (winner.exactMatches || 0) + 1;
        }
        
        // Husky: extra space if won alone
        const soloWin = bids.length === 1;
        if (winner.breed === 'Husky' && soloWin) {
          winner.position++;
          this.addResult(`${winner.name} gains +1 for winning alone!`);
        }
        
        turnWinners.add(winner);
        
        // Track completed project
        if (!winner.completedProjects) winner.completedProjects = [];
        winner.completedProjects.push({
          name: project.name,
          tier: project.tier || 'Entry', 
          spaces: project.reward
        });
        
        // v2.0: Token gains for losers
        losingBidders.forEach(loser => {
          // Golden Retriever: Sympathy token for losing
          if (loser.breed === 'Golden Retriever' && loser.breedTokens < loser.maxTokens) {
            loser.breedTokens++;
            this.showNotification('Sympathy Token', `${loser.name} gained a Sympathy token`);
          }
          // Beagle: Curiosity token for losing
          if (loser.breed === 'Beagle' && loser.breedTokens < loser.maxTokens) {
            loser.breedTokens++;
            this.showNotification('Curiosity Token', `${loser.name} gained a Curiosity token`);
          }
        });
        
        // Pug: gain space for lowest bid
        const lowestBid = bids.reduce((min, bid) => 
          bid.totalEnergy < min.totalEnergy ? bid : min, bids[0]);
        if (lowestBid && lowestBid.player.breed === 'Pug') {
          lowestBid.player.position++;
          this.addResult(`${lowestBid.player.name} gains +1 for adorable incompetence!`);
        }
        
        // Husky: Determination token for solo bid (win or lose)
        if (bids.length === 1 && bids[0].player.breed === 'Husky' && 
            bids[0].player.breedTokens < bids[0].player.maxTokens) {
          bids[0].player.breedTokens++;
          this.showNotification('Determination Token', `${bids[0].player.name} gained a Determination token for solo bid`);
        }
        
        this.addResult(`${winner.name} won "${project.name}" (+${project.reward} spaces)`);
        
        // Check for immediate win conditions
        const winnerIndex = this.state.players.indexOf(winner);
        if (this.checkAgendaWin(winner, winnerIndex)) {
          this.announceWinner(winner, `Hidden Agenda: ${winner.agenda.name}!`);
          return;
        }
      }
      
      // Clear bids
      this.state.players.forEach(player => {
        player.bids[index] = [];
      });
    });
    
    // v2.0: Participation Trophy - players who won no projects climb 1 space
    this.state.players.forEach(player => {
      if (!turnWinners.has(player)) {
        player.position++;
        this.addResult(`${player.name} gets Participation Trophy (+1 space)`);
      }
    });
    
    // Check for win conditions after projects are resolved
    if (this.checkAllWinConditions()) {
      return; // Game is over
    }
    
    // Replace projects
    this.state.projects = this.state.projects.map(() => {
      if (this.state.projectDeck.length > 0) {
        return this.state.projectDeck.shift();
      }
      return null;
    });
    
    setTimeout(() => {
      this.state.phase = 'distraction';
      this.showNotification('Distraction Phase', 'Players may play distractions');
      this.render();
      // After distraction phase, move to cleanup which includes Digging for Treats
      setTimeout(() => this.startCleanupPhase(), 2000);
    }, 1500);
  }

  meetsRequirement(energy, cost) {
    return Object.keys(cost).every(type => energy[type] >= cost[type]);
  }
  
  isExactEnergyMatch(energy, cost) {
    return Object.keys(cost).every(type => energy[type] === cost[type]);
  }

  addResult(message) {
    const log = document.getElementById('resultsLog');
    const entry = document.createElement('div');
    entry.className = 'result-entry';
    entry.textContent = `Turn ${this.state.turn}: ${message}`;
    log.insertBefore(entry, log.firstChild);
    
    // Keep only last 5
    while (log.children.length > 5) {
      log.removeChild(log.lastChild);
    }
  }

  playDistraction(card, player) {
    if (card.targetRequired) {
      this.showTargetSelection(card, player);
    } else {
      this.executeDistraction(null, card, player);
    }
  }

  showTargetSelection(card, player) {
    const container = document.getElementById('targetPlayers');
    container.innerHTML = '';
    
    this.state.players.forEach((target, index) => {
      if (target !== player) {
        const btn = document.createElement('div');
        btn.className = 'target-player';
        btn.textContent = target.name;
        btn.addEventListener('click', () => {
          this.executeDistraction(target, card, player);
        });
        container.appendChild(btn);
      }
    });
    
    document.getElementById('targetModal').classList.add('active');
    this.pendingDistraction = { card, player };
  }

  executeDistraction(target, card, player) {
    // Apply effect
    this.showNotification('Distraction!', `${player.name} played ${card.name} on ${target ? target.name : 'everyone'}`);
    
    // Track distraction for win conditions
    player.distractionsPlayed++;
    if (target) {
      target.distractionsReceived++;
    }
    
    // TODO: Apply actual distraction effects based on card.effect
    
    // Remove card
    player.handDistraction = player.handDistraction.filter(c => c.id !== card.id);
    
    document.getElementById('targetModal').classList.remove('active');
    this.render();
  }

  cancelTargeting() {
    document.getElementById('targetModal').classList.remove('active');
  }

  endDistraction() {
    this.state.phase = 'cleanup';
    this.startCleanupPhase();
  }
  
  startCleanupPhase() {
    this.state.phase = 'cleanup';
    this.showNotification('Cleanup Phase', 'Digging for Treats and drawing cards');
    
    // v2.0: Digging for Treats - each player can discard up to 2 cards and redraw
    this.state.players.forEach(player => {
      // For AI/automated play, randomly decide to dig (50% chance)
      if (Math.random() < 0.5 && player.handAction.length >= 2) {
        const discardCount = Math.min(2, Math.floor(Math.random() * 3));
        if (discardCount > 0) {
          // Discard random cards
          for (let i = 0; i < discardCount; i++) {
            const idx = Math.floor(Math.random() * player.handAction.length);
            player.handAction.splice(idx, 1);
          }
          // Draw replacements
          for (let i = 0; i < discardCount && this.state.actionDeck.length > 0; i++) {
            player.handAction.push(this.state.actionDeck.shift());
          }
          this.addResult(`${player.name} dug for treats (discarded ${discardCount} cards)`);
        }
      }
    });
    
    // Continue with normal cleanup
    this.cleanup();
  }

  cleanup() {
    // Draw cards up to minimum
    this.state.players.forEach(player => {
      // Use player's card minimum (v2.0)
      const minCards = player.cardMinimum || 5;
      
      while (player.handAction.length < minCards && this.state.actionDeck.length > 0) {
        player.handAction.push(this.state.actionDeck.shift());
      }
      
      // Draw 1 distraction card
      if (this.state.distractionDeck.length > 0) {
        player.handDistraction.push(this.state.distractionDeck.shift());
      }
      
      // Reset turn-based breed powers
      player.usedBreedPower = false;
      
      // Golden Retriever gets bonus energy at start of turn
      if (player.breed === 'Golden Retriever') {
        player.bonusEnergy = { comm: 0, focus: 0, social: 1, phys: 0 };  // +1❤️
        this.showNotification('Good Boy Syndrome', `${player.name} gains +1❤️ for this turn`);
      } else {
        player.bonusEnergy = { comm: 0, focus: 0, social: 0, phys: 0 };
      }
    });
    
    // Next turn
    this.state.turn++;
    
    // Check for end-of-turn win conditions (like turn 12 Saboteur)
    if (this.checkAllWinConditions()) {
      return; // Game is over
    }
    
    this.state.firstPlayer = (this.state.firstPlayer + 1) % this.state.players.length;
    this.state.currentPlayer = this.state.firstPlayer;
    this.state.phase = 'bidding';
    this.state.round = 1;
    
    this.render();
  }

  undoLastBid() {
    if (this.state.bidsThisTurn.length === 0) return;
    
    const lastBid = this.state.bidsThisTurn.pop();
    const player = this.state.players[lastBid.player];
    
    // Remove from project
    player.bids[lastBid.project] = player.bids[lastBid.project].filter(
      b => b.id !== lastBid.card.id
    );
    
    // Return to hand
    player.handAction.push(lastBid.card);
    
    this.state.cardsPlayedThisRound = Math.max(0, this.state.cardsPlayedThisRound - 1);
    
    this.render();
  }

  getEnergyEmoji(type) {
    const emojis = { comm: '💬', focus: '⚡', social: '❤️', phys: '💪' };
    return emojis[type] || '';
  }

  getPlayerColorHex(index) {
    const colors = ['#E76F51', '#65C3BA', '#F4A261', '#E9C46A', '#2A4B8D', '#8B9DC3'];
    return colors[index % colors.length];
  }

  getRandomAgenda() {
    // v2.0: Binary end-game checks only
    const agendas = [
      // Achievement-Based
      { name: "The Overachiever", text: "Have completed the most projects (or tied for most)" },
      { name: "The Executive", text: "Be at space 41 or higher (Executive Level)" },
      { name: "The Specialist", text: "Have completed 3+ Management or Executive level projects" },
      { name: "The Perfectionist", text: "Won at least 3 projects with exact energy match (no excess)" },
      
      // Position-Based
      { name: "Middle Management Forever", text: "Be in exactly 3rd place when game ends" },
      { name: "The Underdog", text: "Win from 4th place or lower" },
      { name: "The Steady Climber", text: "Never dropped ladder position (only stayed same or climbed each turn)" },
      
      // Resource-Based
      { name: "The Hoarder", text: "Have 10+ cards in hand at game end" },
      { name: "The Token Master", text: "Have 4+ breed tokens at game end" },
      
      // Interaction-Based
      { name: "The Saboteur", text: "No player reaches CEO (space 50) by Turn 12" },
      { name: "The Enabler", text: "Every other player completed at least 2 projects" },
      { name: "The Survivor", text: "Never targeted by more than 2 Distraction cards total" }
    ];
    
    return agendas[Math.floor(Math.random() * agendas.length)];
  }

  // Modular Agenda Win Condition Checkers
  checkAgendaWin(player, playerIndex) {
    const agenda = player.agenda;
    if (!agenda) return false;
    
    const checker = this.AGENDA_CHECKERS[agenda.name];
    if (!checker) {
      console.warn(`No win checker for agenda: ${agenda.name}`);
      return false;
    }
    
    return checker.call(this, player, playerIndex);
  }
  
  // v2.0: Define all agenda win condition checkers
  AGENDA_CHECKERS = {
    // Achievement-Based
    "The Overachiever": function(player) {
      const maxProjects = Math.max(...this.state.players.map(p => p.completedProjects?.length || 0));
      return (player.completedProjects?.length || 0) >= maxProjects && maxProjects > 0;
    },
    
    "The Executive": function(player) {
      return player.position >= 41;
    },
    
    "The Specialist": function(player) {
      const highTierProjects = (player.completedProjects || []).filter(p => 
        p.tier === 'Management' || p.tier === 'Executive'
      );
      return highTierProjects.length >= 3;
    },
    
    "The Perfectionist": function(player) {
      // Track this during project resolution in v2.0
      return (player.exactMatches || 0) >= 3;
    },
    
    // Position-Based
    "Middle Management Forever": function(player) {
      const sorted = [...this.state.players].sort((a, b) => b.position - a.position);
      const playerRank = sorted.findIndex(p => p.id === player.id) + 1;
      return playerRank === 3;
    },
    
    "The Underdog": function(player) {
      const sorted = [...this.state.players].sort((a, b) => b.position - a.position);
      const playerRank = sorted.findIndex(p => p.id === player.id) + 1;
      const isWinner = sorted[0].id === player.id;
      return isWinner && playerRank >= 4;  // Started 4th or lower, now winner
    },
    
    "The Steady Climber": function(player) {
      // Check position history - never went down
      for (let i = 1; i < player.positionHistory.length; i++) {
        if (player.positionHistory[i] < player.positionHistory[i-1]) {
          return false;
        }
      }
      return true;
    },
    
    // Resource-Based
    "The Hoarder": function(player) {
      return (player.handAction?.length || 0) + (player.handDistraction?.length || 0) >= 10;
    },
    
    "The Token Master": function(player) {
      return player.breedTokens >= 4;
    },
    
    // Interaction-Based
    "The Saboteur": function(player) {
      return !this.state.players.some(p => p.position >= 50);
    },
    
    "The Enabler": function(player) {
      const otherPlayers = this.state.players.filter(p => p.id !== player.id);
      return otherPlayers.every(p => (p.completedProjects?.length || 0) >= 2);
    },
    
    "The Survivor": function(player) {
      return (player.distractionsReceived || 0) <= 2;
    },
    
    "Overachiever": function(player) {
      return player.position >= 52; // CEO is 50, so 52+ is overachieving
    },
    
    "Saboteur": function(player) {
      const noOneAtCEO = !this.state.players.some(p => p.position >= 50);
      return this.state.turn >= 12 && noOneAtCEO;
    },
    
    "Attention Whore": function(player) {
      return player.distractionsReceived >= 4;
    },
    
    "Workaholic": function(player) {
      return player.completedProjects.length >= 8;
    },
    
    "Imposter Syndrome": function(player) {
      const ceoPlayer = this.state.players.find(p => p.position >= 50);
      if (!ceoPlayer || ceoPlayer.id === player.id) return false;
      return ceoPlayer.completedProjects.length < player.completedProjects.length;
    },
    
    "Lucky Bastard": function(player) {
      const executiveProjects = player.completedProjects.filter(p => p.tier === 'Executive');
      return executiveProjects.length >= 2;
    },
    
    "Enabler": function(player, playerIndex) {
      const otherPlayers = this.state.players.filter((p, i) => i !== playerIndex);
      const allHave2Projects = otherPlayers.every(p => p.completedProjects.length >= 2);
      const gameEnding = this.state.turn >= 12 || this.state.players.some(p => p.position >= 50);
      return gameEnding && allHave2Projects;
    },
    
    "Comeback Kid": function(player) {
      // Check if player moved from <=10 to >=40 in this turn
      if (player.lastTurnPosition <= 10 && player.position >= 40) {
        const jump = player.position - player.lastTurnPosition;
        return jump >= 30;
      }
      return false;
    },
    
    "Perfectionist": function(player) {
      const totalSpaces = player.completedProjects.reduce((sum, p) => sum + (p.spaces || 0), 0);
      return totalSpaces === 15;
    }
  };

  checkAllWinConditions() {
    // Check for CEO win
    const ceoWinner = this.state.players.find(p => p.position >= 50);
    if (ceoWinner) {
      // Check if it's an overachiever win
      if (ceoWinner.position >= 52 && ceoWinner.agenda.name === "Overachiever") {
        this.announceWinner(ceoWinner, "Hidden Agenda: Overachiever!");
        return true;
      }
      this.announceWinner(ceoWinner, "Reached CEO!");
      return true;
    }
    
    // Check for turn 12 wins
    if (this.state.turn >= 12) {
      // Check saboteur
      for (let i = 0; i < this.state.players.length; i++) {
        const player = this.state.players[i];
        if (this.checkAgendaWin(player, i)) {
          this.announceWinner(player, `Hidden Agenda: ${player.agenda.name}!`);
          return true;
        }
      }
      
      // No agenda wins, highest position wins
      const winner = [...this.state.players].sort((a, b) => b.position - a.position)[0];
      this.announceWinner(winner, "Highest position at game end!");
      return true;
    }
    
    // Check all other agenda wins
    for (let i = 0; i < this.state.players.length; i++) {
      const player = this.state.players[i];
      if (this.checkAgendaWin(player, i)) {
        this.announceWinner(player, `Hidden Agenda: ${player.agenda.name}!`);
        return true;
      }
    }
    
    return false;
  }

  announceWinner(player, reason) {
    this.state.winner = player;
    this.showNotification('🎉 Game Over!', `${player.name} wins! ${reason}`);
    
    // Show final game state
    setTimeout(() => {
      if (confirm(`${player.name} wins via ${reason}!\n\nPlay again?`)) {
        this.newGame();
      }
    }, 1000);
  }

  saveGame() {
    localStorage.setItem('dogsWithJobsSave', JSON.stringify(this.state));
    this.showNotification('Game Saved', 'Your progress has been saved');
  }

  loadGame() {
    const saved = localStorage.getItem('dogsWithJobsSave');
    if (saved) {
      this.state = JSON.parse(saved);
      this.render();
      this.showNotification('Game Loaded', 'Your save has been restored');
    }
  }

  newGame() {
    this.showSetupModal();
  }
  
  // Debug Panel Methods
  toggleDebugPanel() {
    const panel = document.getElementById('debugPanel');
    if (panel.style.display === 'none') {
      panel.style.display = 'block';
      this.updateDebugAgendas();
    } else {
      panel.style.display = 'none';
    }
  }
  
  updateDebugAgendas() {
    const container = document.getElementById('debugAgendas');
    if (!container || !this.state.players.length) return;
    
    container.innerHTML = this.state.players.map((p, i) => 
      `<div class="debug-agenda-item">
        <strong>${p.name} (${p.breed}):</strong> ${p.agenda ? p.agenda.name : 'No agenda'}
        <br>Projects: ${p.completedProjects?.length || 0} | 
        Pos: ${p.position} | 
        Dist: ${p.distractionsPlayed || 0}
      </div>`
    ).join('');
    
    // Update breed display
    const breedContainer = document.getElementById('debugBreed');
    if (breedContainer) {
      const playerIndex = parseInt(document.getElementById('debugPlayer').value);
      const player = this.state.players[playerIndex];
      if (player) {
        const powers = this.getBreedPowers();
        const power = powers[player.breed];
        breedContainer.innerHTML = power ? 
          `<strong>${player.breed}</strong>: ${power.name}<br>${power.desc}` :
          'No breed power';
      }
    }
  }
  
  testWinCondition() {
    const playerIndex = parseInt(document.getElementById('debugPlayer').value);
    const player = this.state.players[playerIndex];
    if (!player) return;
    
    const result = this.checkAgendaWin(player, playerIndex);
    this.showNotification('Debug', 
      `${player.name}'s agenda "${player.agenda?.name}": ${result ? '✅ MET' : '❌ NOT MET'}`
    );
  }
  
  modifyPosition(amount) {
    const playerIndex = parseInt(document.getElementById('debugPlayer').value);
    const player = this.state.players[playerIndex];
    if (!player) return;
    
    player.position = Math.max(1, Math.min(60, player.position + amount));
    this.render();
    this.updateDebugAgendas();
    this.showNotification('Debug', `${player.name} position: ${player.position}`);
  }
  
  addCompletedProject() {
    const playerIndex = parseInt(document.getElementById('debugPlayer').value);
    const player = this.state.players[playerIndex];
    if (!player) return;
    
    if (!player.completedProjects) player.completedProjects = [];
    player.completedProjects.push({
      name: 'Debug Project',
      tier: 'Management',
      spaces: 3
    });
    
    this.updateDebugAgendas();
    this.showNotification('Debug', `${player.name} projects: ${player.completedProjects.length}`);
  }
  
  addDistraction() {
    const playerIndex = parseInt(document.getElementById('debugPlayer').value);
    const player = this.state.players[playerIndex];
    if (!player) return;
    
    player.distractionsPlayed = (player.distractionsPlayed || 0) + 1;
    this.updateDebugAgendas();
    this.showNotification('Debug', `${player.name} distractions: ${player.distractionsPlayed}`);
  }
  
  setTurn(turn) {
    this.state.turn = turn;
    this.render();
    this.showNotification('Debug', `Turn set to ${turn}`);
  }
  
  triggerWinCheck() {
    const result = this.checkAllWinConditions();
    if (!result) {
      this.showNotification('Debug', 'No win conditions met');
    }
  }
  
  showGameState() {
    console.log('Game State:', this.state);
    this.showNotification('Debug', 'Game state logged to console');
  }
  
  testBreedPower() {
    const playerIndex = parseInt(document.getElementById('debugPlayer').value);
    const player = this.state.players[playerIndex];
    if (!player) return;
    
    switch(player.breed) {
      case 'Golden Retriever':
        player.bonusEnergy = { comm: 0, focus: 0, social: 1, phys: 0 };
        this.showNotification('Debug', `${player.name} gets +1❤️ bonus energy`);
        break;
      case 'Jack Russell':
        if (player.handAction.length >= 2) {
          const discarded = player.handAction.splice(0, 2);
          for (let i = 0; i < 3 && this.state.actionDeck.length > 0; i++) {
            player.handAction.push(this.state.actionDeck.shift());
          }
          this.showNotification('Debug', 'Cocaine Energy: Discarded 2, drew 3');
          this.render();
        }
        break;
      case 'Pug':
        // Test stealing a project
        const otherPlayer = this.state.players[(playerIndex + 1) % this.state.players.length];
        if (otherPlayer.completedProjects?.length > 0) {
          const stolen = otherPlayer.completedProjects.pop();
          if (!player.completedProjects) player.completedProjects = [];
          player.completedProjects.push(stolen);
          this.showNotification('Debug', `Stole project from ${otherPlayer.name}`);
        }
        break;
      default:
        this.showNotification('Debug', `${player.breed} power active`);
    }
    
    this.updateDebugAgendas();
  }
  
  cycleBreed() {
    const playerIndex = parseInt(document.getElementById('debugPlayer').value);
    const player = this.state.players[playerIndex];
    if (!player) return;
    
    const breeds = [
      'Golden Retriever', 'German Shepherd', 'Border Collie', 'Chihuahua',
      'Labrador', 'Beagle', 'Husky', 'Pug', 'Dalmatian', 'Bloodhound',
      'Great Dane', 'Jack Russell', 'Australian Cattle Dog'
    ];
    
    const currentIndex = breeds.indexOf(player.breed);
    player.breed = breeds[(currentIndex + 1) % breeds.length];
    
    this.updateDebugAgendas();
    this.showNotification('Debug', `Changed to ${player.breed}`);
    this.render();
  }
  
  // Breed Power Implementations
  usePugPower(player) {
    if (player.usedBreedPower) {
      this.showNotification('Already Used', 'Pug power can only be used once per game');
      return;
    }
    
    // Find a player with completed projects to steal from
    const otherPlayers = this.state.players.filter(p => p !== player && p.completedProjects?.length > 0);
    if (otherPlayers.length === 0) {
      this.showNotification('No Targets', 'No other players have completed projects to steal');
      return;
    }
    
    // For simplicity, steal from the first available player (could add UI to select)
    const victim = otherPlayers[0];
    const stolenProject = victim.completedProjects.pop();
    
    if (!player.completedProjects) player.completedProjects = [];
    player.completedProjects.push(stolenProject);
    
    player.usedBreedPower = true;
    this.showNotification('Breathing Problems!', 
      `${player.name} stole "${stolenProject.name}" from ${victim.name}!`);
    
    // Check for immediate win
    const playerIndex = this.state.players.indexOf(player);
    if (this.checkAgendaWin(player, playerIndex)) {
      this.announceWinner(player, `Hidden Agenda: ${player.agenda.name}!`);
    }
    
    this.render();
  }
  
  useJackRussellPower(player) {
    if (player.handAction.length < 2) {
      this.showNotification('Not Enough Cards', 'Need at least 2 cards to use Cocaine Energy');
      return;
    }
    
    // Discard 2 cards
    const discarded = player.handAction.splice(0, 2);
    
    // Draw 3 new cards
    let drawn = 0;
    for (let i = 0; i < 3 && this.state.actionDeck.length > 0; i++) {
      player.handAction.push(this.state.actionDeck.shift());
      drawn++;
    }
    
    this.showNotification('Cocaine Energy!', 
      `${player.name} discarded 2 cards and drew ${drawn} new ones!`);
    
    this.render();
  }
  
  useBloodhoundPower(player) {
    if (player.usedBreedPower) {
      this.showNotification('Already Used', 'Bloodhound power can only be used once per game');
      return;
    }
    
    const otherPlayers = this.state.players.filter(p => p !== player);
    if (otherPlayers.length === 0) return;
    
    // For simplicity, peek at the next player's agenda (could add UI to select)
    const target = otherPlayers[0];
    
    player.usedBreedPower = true;
    this.showNotification('Stalker Instincts!', 
      `${player.name} discovered ${target.name}'s Hidden Agenda: ${target.agenda.name}!`);
    
    // Could store this information somewhere for the player to reference later
    this.render();
  }
}

// Initialize game
const game = new DogsWithJobsGame();
</script>
</body>
</html>