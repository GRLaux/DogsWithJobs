<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Dogs With Jobs - Multiplayer Memphis</title>
<script src="/socket.io/socket.io.js"></script>
<style>
  :root {
    --bg-main: #FAF0E6;
    --coral: #E76F51;
    --teal: #65C3BA;
    --peach: #F4A261;
    --yellow: #E9C46A;
    --navy: #2A4B8D;
    --blue-light: #8B9DC3;
    
    --gradient-coral: linear-gradient(135deg, #E76F51, #F4A261);
    --gradient-teal: linear-gradient(135deg, #65C3BA, #2A4B8D);
    --gradient-navy: linear-gradient(135deg, #2A4B8D, #1A1A4A);
    --gradient-rainbow: linear-gradient(45deg, #E76F51, #F4A261, #E9C46A, #65C3BA, #2A4B8D);
    
    --shadow-sm: 0 2px 4px rgba(42,75,141,0.1);
    --shadow-md: 0 4px 12px rgba(42,75,141,0.15);
    --shadow-lg: 0 8px 24px rgba(42,75,141,0.2);
    
    --text-primary: #2A4B8D;
    --text-secondary: #666;
    --border-radius: 12px;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
    background: var(--bg-main);
    color: var(--text-primary);
    min-height: 100vh;
    position: relative;
    overflow-x: hidden;
  }
  
  /* Memphis Background */
  .grid-bg {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: 
      repeating-linear-gradient(0deg, transparent, transparent 100px, rgba(101,195,186,0.05) 100px, rgba(101,195,186,0.05) 101px),
      repeating-linear-gradient(90deg, transparent, transparent 100px, rgba(231,111,81,0.05) 100px, rgba(231,111,81,0.05) 101px);
    pointer-events: none;
    z-index: 0;
  }
  
  /* Geometric decorations */
  .geo-decor {
    position: fixed;
    pointer-events: none;
    z-index: 1;
  }
  
  .geo-1 {
    top: 10%;
    right: 5%;
    width: 80px;
    height: 80px;
    background: var(--gradient-coral);
    border-radius: 50%;
    animation: float 6s ease-in-out infinite;
  }
  
  .geo-2 {
    bottom: 20%;
    left: 3%;
    width: 60px;
    height: 60px;
    background: var(--gradient-teal);
    transform: rotate(45deg);
    animation: rotate 8s linear infinite;
  }
  
  .geo-3 {
    top: 50%;
    left: 10%;
    width: 0;
    height: 0;
    border-left: 40px solid transparent;
    border-right: 40px solid transparent;
    border-bottom: 70px solid var(--peach);
    animation: float 7s ease-in-out infinite reverse;
  }
  
  @keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
  }
  
  @keyframes rotate {
    from { transform: rotate(45deg); }
    to { transform: rotate(405deg); }
  }
  
  /* Progress Track */
  .progress-track {
    background: white;
    border: 4px solid var(--navy);
    border-radius: var(--border-radius);
    padding: 1rem;
    margin: 1rem auto;
    max-width: 1400px;
    box-shadow: var(--shadow-lg);
    position: relative;
    z-index: 100;
  }
  
  .track-label {
    font-weight: bold;
    color: var(--navy);
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
  }
  
  .track-spaces {
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
    padding: 0.5rem 0;
  }
  
  .space {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--bg-main);
    border: 2px solid var(--blue-light);
    position: relative;
    transition: all 0.3s;
  }
  
  .space.milestone {
    width: 20px;
    height: 20px;
    background: var(--gradient-coral);
    border: none;
  }
  
  .space.finish {
    width: 24px;
    height: 24px;
    background: var(--gradient-rainbow);
    border: none;
  }
  
  .pawn {
    position: absolute;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: 3px solid white;
    transform: translate(-50%, -50%);
    top: 50%;
    transition: left 0.5s ease-out;
    z-index: 10;
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  
  /* Header */
  .game-header {
    background: white;
    border-bottom: 4px solid var(--navy);
    padding: 1rem;
    box-shadow: var(--shadow-lg);
    position: relative;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .header-title {
    font-size: 1.5rem;
    font-weight: 900;
    background: var(--gradient-rainbow);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  .turn-info {
    display: flex;
    gap: 1rem;
    align-items: center;
  }
  
  .turn-badge {
    background: var(--gradient-coral);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 25px;
    font-weight: bold;
    box-shadow: var(--shadow-md);
  }
  
  .current-player-badge {
    background: var(--gradient-teal);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 25px;
    font-weight: bold;
    box-shadow: var(--shadow-md);
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
  }
  
  /* Game Container */
  .game-container {
    max-width: 1400px;
    margin: 2rem auto;
    padding: 0 1rem;
    position: relative;
    z-index: 10;
  }
  
  /* Opponents Section */
  .opponents-section {
    margin-bottom: 2rem;
  }
  
  .section-title {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--navy);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  .opponents-grid {
    display: flex;
    gap: 1rem;
    overflow-x: auto;
    padding-bottom: 0.5rem;
  }
  
  .opponent-card {
    background: white;
    border: 3px solid var(--teal);
    border-radius: var(--border-radius);
    padding: 1rem;
    min-width: 180px;
    box-shadow: var(--shadow-md);
    position: relative;
    transition: transform 0.3s;
  }
  
  .opponent-card:hover {
    transform: translateY(-5px);
    box-shadow: var(--shadow-lg);
  }
  
  .opponent-card.is-current {
    border-color: var(--coral);
    background: linear-gradient(135deg, rgba(231,111,81,0.1), rgba(244,162,97,0.1));
    animation: glow 2s infinite;
  }
  
  @keyframes glow {
    0%, 100% { box-shadow: 0 0 20px rgba(231,111,81,0.3); }
    50% { box-shadow: 0 0 40px rgba(231,111,81,0.5); }
  }
  
  .opponent-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
  }
  
  .opponent-name {
    font-weight: bold;
    color: var(--navy);
  }
  
  .opponent-position {
    background: var(--gradient-teal);
    color: white;
    padding: 0.2rem 0.5rem;
    border-radius: 12px;
    font-size: 0.8rem;
  }
  
  .opponent-breed {
    color: var(--text-secondary);
    font-size: 0.9rem;
    font-style: italic;
    margin-bottom: 0.5rem;
  }
  
  .opponent-hand {
    display: flex;
    gap: 3px;
    margin-top: 0.5rem;
  }
  
  .card-back {
    width: 25px;
    height: 35px;
    background: var(--gradient-navy);
    border-radius: 4px;
    border: 1px solid var(--navy);
    position: relative;
    overflow: hidden;
  }
  
  .card-back::after {
    content: 'üêï';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    opacity: 0.3;
  }
  
  /* Projects Section */
  .projects-section {
    margin-bottom: 2rem;
  }
  
  .projects-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
  }
  
  .project-card {
    background: white;
    border: 3px solid var(--yellow);
    border-radius: var(--border-radius);
    padding: 1rem;
    box-shadow: var(--shadow-md);
    position: relative;
    transition: all 0.3s;
  }
  
  .project-card.can-drop {
    border-color: var(--teal);
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(101,195,186,0.4);
  }
  
  .project-tier {
    position: absolute;
    top: -12px;
    right: 12px;
    background: var(--gradient-coral);
    color: white;
    padding: 0.3rem 0.8rem;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: bold;
    text-transform: uppercase;
  }
  
  /* Bid visualizations */
  .my-bids {
    position: absolute;
    top: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    z-index: 10;
  }
  
  .bid-icon {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    animation: bidPlaced 0.3s ease-out;
  }
  
  .opponent-bids {
    position: absolute;
    bottom: 8px;
    right: 8px;
    display: flex;
    gap: 4px;
    z-index: 10;
  }
  
  .opponent-bid-marker {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    animation: opponentBid 0.4s ease-out;
    color: white;
    font-weight: bold;
    font-size: 12px;
  }
  
  .opponent-bid-marker.player-0 { background: linear-gradient(135deg, #e76f51, #ff8b6f); }
  .opponent-bid-marker.player-1 { background: linear-gradient(135deg, #65c3ba, #7fd8cf); }
  .opponent-bid-marker.player-2 { background: linear-gradient(135deg, #f4a261, #f9b77d); }
  .opponent-bid-marker.player-3 { background: linear-gradient(135deg, #e9c46a, #f0d282); }
  .opponent-bid-marker.player-4 { background: linear-gradient(135deg, #2a4b8d, #3a5ba0); }
  .opponent-bid-marker.player-5 { background: linear-gradient(135deg, #8b9dc3, #9fb0d6); }
  
  @keyframes bidPlaced {
    0% { transform: scale(0) rotate(0deg); opacity: 0; }
    50% { transform: scale(1.2) rotate(180deg); }
    100% { transform: scale(1) rotate(360deg); opacity: 1; }
  }
  
  @keyframes opponentBid {
    0% { transform: translateY(20px) scale(0); opacity: 0; }
    100% { transform: translateY(0) scale(1); opacity: 1; }
  }
  
  /* Project Winner Announcements */
  .announcement-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    animation: fadeIn 0.3s ease-out;
  }
  
  .winner-announcement {
    background: linear-gradient(135deg, white, #f5f5f5);
    border: 4px solid var(--coral);
    border-radius: 20px;
    padding: 2rem 3rem;
    margin: 1rem;
    text-align: center;
    animation: slideInScale 0.5s ease-out;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
  }
  
  .winner-name {
    font-size: 2rem;
    font-weight: bold;
    color: var(--coral);
    margin-bottom: 0.5rem;
    text-transform: uppercase;
  }
  
  .winner-project {
    font-size: 1.5rem;
    color: var(--navy);
    margin-bottom: 1rem;
  }
  
  .winner-energy {
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    font-size: 1.5rem;
    margin-bottom: 1rem;
  }
  
  .turn-transition {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 5rem;
    font-weight: bold;
    color: white;
    text-shadow: 0 0 40px rgba(101,195,186,0.8);
    z-index: 10001;
    animation: turnReveal 2s ease-out;
  }
  
  .distraction-drop-zone {
    margin-top: 20px;
    padding: 30px;
    border: 3px dashed var(--yellow);
    border-radius: 15px;
    background: rgba(244, 162, 97, 0.1);
    text-align: center;
    transition: all 0.3s ease;
  }
  
  .distraction-drop-zone.drag-over {
    background: rgba(244, 162, 97, 0.3);
    border-color: var(--coral);
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(244, 162, 97, 0.5);
  }
  
  .drop-zone-text {
    font-size: 1.3rem;
    font-weight: bold;
    color: var(--yellow);
    margin-bottom: 10px;
  }
  
  .drop-zone-hint {
    font-size: 0.9rem;
    color: var(--beige);
    opacity: 0.8;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes slideInScale {
    from { transform: translateY(-50px) scale(0.8); opacity: 0; }
    to { transform: translateY(0) scale(1); opacity: 1; }
  }
  
  @keyframes turnReveal {
    0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2) rotate(0deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0; }
  }
  
  .project-tier.Management {
    background: var(--gradient-teal);
  }
  
  .project-tier.Executive {
    background: var(--gradient-navy);
  }
  
  .project-name {
    font-weight: bold;
    color: var(--navy);
    margin: 0.5rem 0;
    font-size: 1rem;
  }
  
  .project-requirements {
    display: flex;
    gap: 0.5rem;
    margin: 0.5rem 0;
    flex-wrap: wrap;
  }
  
  .energy-badge {
    display: inline-block;
    font-size: 20px;
    margin: 0 2px;
  }
  
  .bid-marker {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 30px;
    height: 30px;
    background: linear-gradient(135deg, #E76F51, #F4A261);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    border: 2px solid white;
    box-shadow: 0 4px 12px rgba(42,75,141,0.15);
    animation: bounceIn 0.5s;
  }
  
  @keyframes bounceIn {
    0% { transform: scale(0); }
    60% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }
  
  .project-reward {
    text-align: center;
    margin-top: 0.5rem;
    padding-top: 0.5rem;
    border-top: 2px dashed var(--yellow);
    color: var(--teal);
    font-weight: bold;
  }
  
  /* My Hand Section */
  .my-hand-section {
    background: white;
    border: 4px solid var(--navy);
    border-radius: var(--border-radius);
    padding: 1.5rem;
    box-shadow: var(--shadow-lg);
    position: sticky;
    bottom: 20px;
  }
  
  .my-info {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 1rem;
    margin-bottom: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(101,195,186,0.1), rgba(42,75,141,0.1));
    border-radius: var(--border-radius);
  }
  
  .info-block {
    text-align: center;
  }
  
  .info-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 0.25rem;
  }
  
  .info-value {
    font-weight: bold;
    color: var(--navy);
  }
  
  .my-agenda {
    background: var(--gradient-coral);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    text-align: center;
    font-weight: bold;
  }
  
  .my-cards {
    display: flex;
    gap: 1rem;
    overflow-x: auto;
    padding: 1rem 0;
  }
  
  .action-card {
    background: white;
    border: 3px solid var(--coral);
    border-radius: var(--border-radius);
    padding: 1rem;
    min-width: 140px;
    cursor: move;
    transition: all 0.3s;
    box-shadow: var(--shadow-md);
    position: relative;
  }
  
  .action-card:hover {
    transform: translateY(-10px) rotate(2deg);
    box-shadow: var(--shadow-lg);
    border-color: var(--teal);
  }
  
  .action-card.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
  }
  
  .card-name {
    font-weight: bold;
    color: var(--navy);
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
  }
  
  .card-energy {
    display: flex;
    gap: 0.25rem;
    justify-content: center;
  }
  
  /* Tooltip */
  .tooltip {
    position: absolute;
    background: white;
    border: 3px solid var(--coral);
    padding: 0.75rem;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-lg);
    z-index: 1000;
    display: none;
    max-width: 250px;
    pointer-events: none;
  }
  
  .tooltip.show {
    display: block;
  }
  
  .tooltip-title {
    font-weight: bold;
    margin-bottom: 0.25rem;
    color: var(--navy);
  }
  
  .tooltip-desc {
    font-size: 0.85rem;
    color: var(--text-secondary);
  }
  
  /* Notifications */
  .game-notification {
    position: fixed;
    top: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: white;
    border: 3px solid var(--coral);
    padding: 1rem 2rem;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-lg);
    z-index: 10000;
    animation: slideInBounce 0.5s ease-out;
  }
  
  @keyframes slideInBounce {
    0% { 
      transform: translateX(-50%) translateY(-200px);
      opacity: 0;
    }
    60% { 
      transform: translateX(-50%) translateY(20px);
      opacity: 1;
    }
    100% { 
      transform: translateX(-50%) translateY(0);
    }
  }
</style>
</head>
<body>
<div class="grid-bg"></div>
<div class="geo-decor geo-1"></div>
<div class="geo-decor geo-2"></div>
<div class="geo-decor geo-3"></div>

<header class="game-header">
  <h1 class="header-title">üêï Dogs With Jobs üéØ</h1>
  <div class="turn-info">
    <div class="turn-badge" id="turnDisplay">Turn 1</div>
    <div class="phase-badge" id="phaseDisplay" style="background: linear-gradient(135deg, #65C3BA, #7FD8CF); color: white; padding: 0.5rem 1rem; border-radius: 20px; font-weight: bold; font-size: 0.9rem;">Round 1/3</div>
    <div class="current-player-badge" id="currentPlayerDisplay">Loading...</div>
    <button id="drawCardBtn" onclick="drawCard()" style="display: none; background: linear-gradient(135deg, #2A4B8D, #8B9DC3); color: white; padding: 0.5rem 1rem; border: none; border-radius: 25px; font-weight: bold; cursor: pointer; margin-left: 1rem; box-shadow: 0 4px 12px rgba(42,75,141,0.15);">Draw Card</button>
    <button id="endTurnBtn" onclick="endTurn()" style="display: none; background: linear-gradient(135deg, #E76F51, #F4A261); color: white; padding: 0.5rem 1rem; border: none; border-radius: 25px; font-weight: bold; cursor: pointer; margin-left: 1rem; box-shadow: 0 4px 12px rgba(42,75,141,0.15);">End Turn</button>
    <button id="endDistractionBtn" onclick="endDistraction()" style="display: none; background: linear-gradient(135deg, #764ba2, #667eea); color: white; padding: 0.5rem 1rem; border: none; border-radius: 25px; font-weight: bold; cursor: pointer; margin-left: 1rem; box-shadow: 0 4px 12px rgba(42,75,141,0.15);">End Distraction Phase</button>
  </div>
</header>

<!-- Progress Track -->
<div class="progress-track">
  <div class="track-label">üèÅ Corporate Ladder Progress</div>
  <div class="track-spaces" id="trackSpaces">
    <!-- Spaces will be generated here -->
  </div>
</div>

<div class="game-container">
  <!-- Players -->
  <div class="opponents-section">
    <h2 class="section-title">üë• Players</h2>
    <div class="opponents-grid" id="opponentsArea"></div>
  </div>
  
  <!-- Projects -->
  <div class="projects-section">
    <h2 class="section-title">üìã Available Projects</h2>
    <div class="projects-grid" id="projectsArea"></div>
    <!-- Instant Distraction Drop Zone -->
    <div class="distraction-drop-zone" id="distractionDropZone" style="display: none;">
      <div class="drop-zone-text">üéØ Drop Instant Distraction Here</div>
      <div class="drop-zone-hint">Play during bidding rounds</div>
    </div>
  </div>
  
  <!-- My Hand -->
  <div class="my-hand-section">
    <div class="my-info">
      <div class="info-block">
        <div class="info-label">Your Breed</div>
        <div class="info-value" id="myBreed">Loading...</div>
      </div>
      <div class="info-block">
        <div class="my-agenda" id="myAgenda">Loading Agenda...</div>
      </div>
      <div class="info-block">
        <div class="info-label">Position</div>
        <div class="info-value">Space <span id="myPosition">1</span></div>
      </div>
      <div class="info-block" style="background: linear-gradient(135deg, #F4A261, #E9C46A); padding: 0.5rem; border-radius: 10px;">
        <div class="info-label">Bonus Energy</div>
        <div class="info-value" style="font-size: 1.2rem;">+1 üí¨</div>
      </div>
    </div>
    <h3 class="section-title">üé¥ Your Hand</h3>
    <div class="my-cards" id="myCards"></div>
  </div>
</div>

<!-- Tooltip -->
<div id="tooltip" class="tooltip">
  <div class="tooltip-title"></div>
  <div class="tooltip-desc"></div>
</div>

<script>
const socket = io();
let gameState = null;
let myPlayerId = null;
let draggedCard = null;
let playerColors = {};

// Memphis color palette for players
const PLAYER_COLORS = ['#E76F51', '#65C3BA', '#F4A261', '#E9C46A', '#2A4B8D', '#8B9DC3'];

// Breed powers data
const BREED_POWERS = {
  "Golden Retriever": "+1‚ù§Ô∏è each turn when leading",
  "German Shepherd": "+1‚ö° on Management projects", 
  "Border Collie": "Draw 6 action cards instead of 5",
  "Chihuahua": "+1üí¨ on Executive projects",
  "Labrador": "Can play 2 cards per turn",
  "Beagle": "Can peek at one opponent's bid",
  "Husky": "Immune to Pack Mentality distractions",
  "Pug": "Once per game: steal a completed project",
  "Dalmatian": "+2üí™ when completing a project",
  "Bloodhound": "Once per game: peek at an opponent's agenda",
  "Great Dane": "Needs 2 distractions to be affected",
  "Jack Russell": "Once per turn: discard 2 to draw 3",
  "Australian Cattle Dog": "Can play 2 distractions per turn"
};

// Get player ID and room info from session/URL
const urlParams = new URLSearchParams(window.location.search);
let storedPlayerId = urlParams.get('playerId') || sessionStorage.getItem('playerId');
let roomCode = sessionStorage.getItem('roomCode');
let playerName = sessionStorage.getItem('playerName');
console.log('Stored player ID:', storedPlayerId, 'Room:', roomCode, 'Name:', playerName);

// Connect and rejoin room
socket.on('connect', () => {
  console.log('Socket connected, new ID:', socket.id);
  myPlayerId = socket.id; // Use current socket ID
  
  // If we have room info, rejoin the room
  if (roomCode && playerName) {
    console.log('Attempting to rejoin room', roomCode, 'as', playerName);
    socket.emit('rejoin-game', {
      roomCode: roomCode,
      playerName: playerName,
      oldPlayerId: storedPlayerId
    });
  } else {
    console.log('No room info found, likely a stale session');
    showNotification('Session expired. Please create or join a new game.');
    setTimeout(() => {
      sessionStorage.clear();
      window.location.href = '/';
    }, 2000);
  }
});

// Initialize progress track
function initializeTrack() {
  const track = document.getElementById('trackSpaces');
  track.innerHTML = '';
  
  for (let i = 0; i <= 50; i++) {
    const space = document.createElement('div');
    space.className = 'space';
    if (i % 10 === 0 && i !== 0) {
      space.className += ' milestone';
    }
    if (i === 50) {
      space.className += ' finish';
    }
    space.dataset.position = i;
    track.appendChild(space);
  }
}

// Add pawn to track
function addPawn(playerId, position, color, emoji = 'üêï') {
  let pawn = document.getElementById(`pawn-${playerId}`);
  if (!pawn) {
    pawn = document.createElement('div');
    pawn.id = `pawn-${playerId}`;
    pawn.className = 'pawn';
    pawn.style.background = color;
    pawn.textContent = emoji;
    document.getElementById('trackSpaces').appendChild(pawn);
  }
  
  const leftPercent = (position / 50) * 100;
  pawn.style.left = `${leftPercent}%`;
}

// Load initial game data from session storage
const initialData = sessionStorage.getItem('gameData');
if (initialData) {
  gameState = JSON.parse(initialData);
  setTimeout(() => renderGame(), 100);
}

// Socket events
socket.on('game-started', (data) => {
  console.log('Game started event received:', data);
  gameState = data;
  // Update player ID to current socket ID
  myPlayerId = socket.id;
  renderGame();
});

socket.on('distraction-played', (data) => {
  console.log('Distraction played:', data);
  showNotification(data.effect);
});

socket.on('player-drew-card', (data) => {
  console.log('Player drew card:', data);
  const message = data.playerId === myPlayerId ? 
    'You drew a card' : 
    `${data.playerName} drew a card`;
  showNotification(message);
});

socket.on('bid-failed', (data) => {
  console.log('Bid failed:', data);
  showNotification(data.message);
  // Re-render to restore the card that was removed from local state
  renderMyHand();
});

socket.on('game-updated', (data) => {
  console.log('Game updated event received:', data);
  console.log('Previous turn:', gameState?.turn, 'New turn:', data.turn);
  console.log('Previous current player:', gameState?.currentPlayer, 'New current player:', data.currentPlayer);
  
  // Check if we have project winners to announce
  if (data.projectWinners && data.projectWinners.length > 0) {
    showProjectWinners(data.projectWinners, () => {
      // After announcements, show turn transition if it's a new turn
      if (gameState && data.turn > gameState.turn) {
        showTurnTransition(data.turn, () => {
          gameState = data;
          renderGame();
        });
      } else {
        gameState = data;
        renderGame();
      }
    });
  } else if (gameState && data.turn > gameState.turn) {
    showTurnTransition(data.turn, () => {
      gameState = data;
      renderGame();
    });
  } else {
    gameState = data;
    renderGame();
  }
});

// Handle rejoin success
socket.on('rejoin-success', (data) => {
  console.log('Rejoined game successfully:', data);
  gameState = data;
  renderGame();
});

// Handle errors
socket.on('error', (message) => {
  console.error('Server error:', message);
  showNotification(`Error: ${message}`);
  
  // Redirect to lobby for room issues
  if (message.includes('Room not found') || message.includes('Not in a room')) {
    showNotification('Room no longer exists. Returning to lobby...');
    setTimeout(() => {
      sessionStorage.clear();
      window.location.href = '/';
    }, 2000);
  }
});

socket.on('opponent-bid', (data) => {
  showNotification(`${data.playerName || 'Opponent'} placed a bid!`);
});

// Render game
function renderGame() {
  if (!gameState || !gameState.myData) {
    console.log('Waiting for game state...', gameState);
    return;
  }
  
  console.log('Rendering game - Turn:', gameState.turn, 'Current player:', gameState.currentPlayerName, 'Is my turn:', gameState.isMyTurn);
  
  // Assign player color
  if (!playerColors[myPlayerId]) {
    playerColors[myPlayerId] = PLAYER_COLORS[0];
  }
  
  // Update header with round and phase info  
  document.getElementById('turnDisplay').textContent = `Turn ${gameState.turn || 1}`;
  
  // Show/hide instant distraction drop zone
  const dropZone = document.getElementById('distractionDropZone');
  if (gameState.phase === 'bidding' && gameState.isMyTurn) {
    dropZone.style.display = 'block';
    setupDropZone();
  } else {
    dropZone.style.display = 'none';
  }
  
  // Show round/phase information
  let phaseText = '';
  if (gameState.phase === 'bidding') {
    phaseText = `Round ${gameState.round || 1}/3`;
  } else if (gameState.phase === 'distraction') {
    phaseText = 'Distraction Phase';
  } else {
    phaseText = 'Cleanup Phase';
  }
  
  const phaseDisplay = document.getElementById('phaseDisplay');
  if (phaseDisplay) {
    phaseDisplay.textContent = phaseText;
  }
  
  document.getElementById('currentPlayerDisplay').textContent = 
    gameState.isMyTurn ? 'üéÆ Your Turn!' : `‚è≥ ${gameState.currentPlayerName}'s Turn`;
  
  // Show/hide appropriate buttons based on phase
  const endBtn = document.getElementById('endTurnBtn');
  const drawBtn = document.getElementById('drawCardBtn');
  const endDistBtn = document.getElementById('endDistractionBtn');
  
  // Check if player can still play cards
  const cardsPlayed = gameState.cardsPlayedThisRound || 0;
  const maxCards = gameState.maxCardsPerRound || 1;
  const canPlayMore = cardsPlayed < maxCards;
  
  if (endBtn) {
    endBtn.style.display = (gameState.isMyTurn && gameState.phase === 'bidding') ? 'inline-block' : 'none';
    endBtn.textContent = `End Turn (Round ${gameState.round || 1})`;
  }
  
  if (drawBtn) {
    // Only show draw button if they haven't played any cards yet
    drawBtn.style.display = (gameState.isMyTurn && gameState.phase === 'bidding' && cardsPlayed === 0) ? 'inline-block' : 'none';
  }
  
  if (endDistBtn) {
    endDistBtn.style.display = (gameState.phase === 'distraction') ? 'inline-block' : 'none';
  }
  
  // Add player pawn
  addPawn(myPlayerId, gameState.myData.position || 0, playerColors[myPlayerId]);
  
  // Render all sections
  renderOpponents();
  renderProjects();
  renderMyHand();
}

function renderOpponents() {
  const area = document.getElementById('opponentsArea');
  area.innerHTML = '';
  
  // Build list of all players (self + opponents)
  const allPlayers = [];
  
  // Add self first
  if (gameState.myData) {
    allPlayers.push({
      id: myPlayerId,
      name: gameState.myData.name || 'You',
      breed: gameState.myData.breed,
      position: gameState.myData.position || 0,
      handActionSize: gameState.myData.handAction?.length || 0,
      handDistractionSize: gameState.myData.handDistraction?.length || 0,
      completedProjects: gameState.myData.completedProjects?.length || 0,
      distractionsPlayed: gameState.myData.distractionsPlayed || 0,
      isSelf: true
    });
  }
  
  // Add opponents
  if (gameState.opponents) {
    gameState.opponents.forEach(opp => {
      allPlayers.push({...opp, isSelf: false});
    });
  }
  
  // Render all players
  allPlayers.forEach((player, index) => {
    const color = PLAYER_COLORS[index % PLAYER_COLORS.length];
    playerColors[player.id] = color;
    
    // Add pawn to track
    addPawn(player.id, player.position || 0, color);
    
    const card = document.createElement('div');
    card.className = 'opponent-card';
    if (player.name === gameState.currentPlayerName) {
      card.classList.add('is-current');
    }
    if (player.isSelf) {
      card.style.background = 'linear-gradient(135deg, rgba(101,195,186,0.1), white)';
    }
    
    // Breed tooltip
    const breedHtml = player.breed ? 
      `<div class="opponent-breed" onmouseover="showBreedTooltip(event, '${player.breed}')" onmouseout="hideTooltip()">üêï ${player.breed}</div>` :
      '<div class="opponent-breed">üêï Unknown</div>';
    
    card.innerHTML = `
      <div class="opponent-header">
        <div class="opponent-name">${player.name}${player.isSelf ? ' (You)' : ''}</div>
        <div class="opponent-position">Lvl ${player.position || 0}</div>
      </div>
      ${breedHtml}
      <div class="opponent-hand">
        ${Array(player.handActionSize || 0).fill('<div class="card-back"></div>').join('')}
      </div>
      <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
        Projects: ${player.completedProjects || 0} | Distractions: ${player.distractionsPlayed || 0}
      </div>
    `;
    
    card.style.borderColor = color;
    area.appendChild(card);
  });
}

function renderProjects() {
  const area = document.getElementById('projectsArea');
  if (!gameState.projects) return;
  
  area.innerHTML = '';
  
  gameState.projects.forEach((project, index) => {
    const card = document.createElement('div');
    card.className = 'project-card';
    card.dataset.index = index;
    
    // Parse requirements from cost object
    let reqHtml = '';
    if (project.cost) {
      const emojis = {
        comm: 'üí¨',
        focus: '‚ö°',
        social: '‚ù§Ô∏è',
        phys: 'üí™'
      };
      
      const reqs = [];
      for (const [type, count] of Object.entries(project.cost)) {
        if (count > 0 && emojis[type]) {
          for (let i = 0; i < count; i++) {
            reqs.push(`<span class="energy-badge">${emojis[type]}</span>`);
          }
        }
      }
      reqHtml = reqs.join('');
    }
    
    // Determine tier
    const tier = project.tier || (project.reward >= 5 ? 'Executive' : project.reward >= 3 ? 'Management' : 'Entry');
    
    // Build my bids visualization
    let myBidsHtml = '';
    if (gameState.myData && gameState.myData.bids && gameState.myData.bids[index]) {
      const myBids = gameState.myData.bids[index];
      if (myBids.length > 0) {
        const bidIcons = [];
        myBids.forEach(bid => {
          const typeEmoji = {comm: 'üí¨', focus: '‚ö°', social: '‚ù§Ô∏è', phys: 'üí™'};
          if (bid.card && bid.card.energy) {
            // Show an icon for each energy type on the card
            Object.entries(bid.card.energy).forEach(([type, value]) => {
              if (value > 0) {
                for (let i = 0; i < value; i++) {
                  bidIcons.push(`<div class="bid-icon" title="${bid.card.name || 'Bid'}: ${value} ${type}">${typeEmoji[type] || '?'}</div>`);
                }
              }
            });
          }
        });
        if (bidIcons.length > 0) {
          myBidsHtml = `<div class="my-bids">${bidIcons.join('')}</div>`;
        }
      }
    }
    
    // Build opponent bids visualization
    let opponentBidsHtml = '';
    if (gameState.opponents) {
      const opponentBids = [];
      gameState.opponents.forEach((opp, oppIndex) => {
        if (opp.bids && opp.bids[index] === true) {
          const playerColorIndex = gameState.opponents.indexOf(opp);
          const initial = opp.name.charAt(0).toUpperCase();
          opponentBids.push(
            `<div class="opponent-bid-marker player-${playerColorIndex}" title="${opp.name} has bid here">${initial}</div>`
          );
        }
      });
      if (opponentBids.length > 0) {
        opponentBidsHtml = `<div class="opponent-bids">${opponentBids.join('')}</div>`;
      }
    }
    
    card.innerHTML = `
      ${myBidsHtml}
      ${opponentBidsHtml}
      <div class="project-tier ${tier}">${tier}</div>
      <div class="project-name" style="${myBidsHtml ? 'margin-top: 30px;' : ''}">${project.name}</div>
      <div class="project-requirements">${reqHtml || '<span style="color: var(--text-secondary); font-size: 0.9rem;">No requirements</span>'}</div>
      <div class="project-reward">üöÄ +${project.reward || 2} spaces</div>
    `;
    
    // Make it a drop zone
    card.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (gameState.isMyTurn) {
        card.classList.add('can-drop');
      }
    });
    
    card.addEventListener('dragleave', () => {
      card.classList.remove('can-drop');
    });
    
    card.addEventListener('drop', (e) => {
      e.preventDefault();
      card.classList.remove('can-drop');
      if (draggedCard && gameState.isMyTurn) {
        placeBid(index, draggedCard);
      }
    });
    
    area.appendChild(card);
  });
}

function renderMyHand() {
  const myData = gameState.myData;
  if (!myData) return;
  
  // Update my info with breed power tooltip
  const breedEl = document.getElementById('myBreed');
  breedEl.textContent = myData.breed || 'Unknown Breed';
  breedEl.style.cursor = 'pointer';
  breedEl.style.textDecoration = 'underline';
  breedEl.title = BREED_POWERS[myData.breed] || 'No special power';
  breedEl.onmouseover = (e) => showBreedTooltip(e, myData.breed);
  breedEl.onmouseout = hideTooltip;
  
  // Update agenda with requirements - using 'text' field from agenda
  const agendaEl = document.getElementById('myAgenda');
  if (myData.agenda) {
    const req = myData.agenda.text || myData.agenda.description || myData.agenda.requirement || 'Win condition';
    agendaEl.style.cursor = 'pointer';
    agendaEl.title = req;
    agendaEl.innerHTML = `üéØ ${myData.agenda.name}<div style="font-size: 0.8rem; margin-top: 0.25rem; color: white; opacity: 0.9;">${req}</div>`;
  } else {
    agendaEl.textContent = 'No Agenda';
  }
  
  document.getElementById('myPosition').textContent = myData.position || 0;
  
  // Render cards
  const cardsArea = document.getElementById('myCards');
  cardsArea.innerHTML = '';
  
  if (!myData.handAction || myData.handAction.length === 0) {
    cardsArea.innerHTML = '<div style="color: var(--text-secondary);">No cards in hand</div>';
    return;
  }
  
  myData.handAction.forEach((card, index) => {
    const cardEl = document.createElement('div');
    const isUsed = myData.usedCards && myData.usedCards.includes(card.id);
    cardEl.className = 'action-card' + (isUsed ? ' used-card' : '');
    
    // Check if player has reached their card limit for this round
    const cardsPlayed = gameState.cardsPlayedThisRound || 0;
    const maxCards = gameState.maxCardsPerRound || 1;
    const canPlayMore = cardsPlayed < maxCards;
    
    // Cards are draggable only if: it's my turn, card not used, and haven't hit limit
    cardEl.draggable = gameState.isMyTurn && !isUsed && canPlayMore;
    
    // Add visual indicator for used cards or when limit reached
    if (isUsed) {
      cardEl.style.opacity = '0.5';
      cardEl.style.background = 'linear-gradient(135deg, #cccccc, #eeeeee)';
    } else if (!canPlayMore && gameState.isMyTurn) {
      cardEl.style.opacity = '0.7';
      cardEl.style.cursor = 'not-allowed';
    }
    
    // Parse card energy object correctly
    let energyHtml = '';
    if (card.energy) {
      const emojis = {
        comm: 'üí¨',
        focus: '‚ö°',
        social: '‚ù§Ô∏è',
        phys: 'üí™'
      };
      
      const energies = [];
      for (const [type, count] of Object.entries(card.energy)) {
        if (count > 0 && emojis[type]) {
          for (let i = 0; i < count; i++) {
            energies.push(`<span class="energy-badge">${emojis[type]}</span>`);
          }
        }
      }
      energyHtml = energies.join('');
    }
    
    cardEl.innerHTML = `
      <div class="card-name">${card.name}</div>
      <div class="card-energy">${energyHtml}</div>
    `;
    
    if (gameState.isMyTurn) {
      cardEl.addEventListener('dragstart', (e) => {
        draggedCard = card;
        cardEl.classList.add('dragging');
      });
      
      cardEl.addEventListener('dragend', () => {
        draggedCard = null;
        cardEl.classList.remove('dragging');
      });
    }
    
    cardsArea.appendChild(cardEl);
  });
  
  // Add distraction cards if any
  if (myData.handDistraction && myData.handDistraction.length > 0) {
    myData.handDistraction.forEach((card, index) => {
      const cardEl = document.createElement('div');
      cardEl.className = 'action-card distraction-card';
      cardEl.style.borderColor = 'var(--coral)';
      cardEl.style.background = 'linear-gradient(135deg, rgba(231,111,81,0.1), white)';
      cardEl.style.position = 'relative';
      
      // Determine if instant or end-of-turn
      const isInstant = card.type === 'instant';
      const badgeColor = isInstant ? 'var(--teal)' : 'var(--yellow)';
      const badgeText = isInstant ? 'INSTANT' : 'END';
      
      cardEl.innerHTML = `
        <div style="position: absolute; top: -10px; right: -5px; background: ${badgeColor}; color: white; padding: 0.2rem 0.5rem; border-radius: 12px; font-size: 0.7rem; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${badgeText}</div>
        <div class="card-name">${card.name}</div>
        <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.5rem;">${card.effect || 'Distraction'}</div>
      `;
      
      // Make instant cards draggable during bidding phase
      if (isInstant && gameState.phase === 'bidding') {
        cardEl.draggable = true;
        cardEl.dataset.cardIndex = index;
        cardEl.dataset.cardType = 'distraction';
        cardEl.dataset.cardId = card.id;
        cardEl.style.cursor = 'grab';
        
        cardEl.addEventListener('dragstart', (e) => {
          draggedCard = card;
          draggedCardElement = cardEl;
          draggedCardIndex = index;
          cardEl.classList.add('dragging');
          cardEl.style.opacity = '0.5';
          e.dataTransfer.effectAllowed = 'move';
        });
        
        cardEl.addEventListener('dragend', () => {
          draggedCard = null;
          draggedCardElement = null;
          draggedCardIndex = null;
          cardEl.classList.remove('dragging');
          cardEl.style.opacity = '1';
        });
      }
      
      cardsArea.appendChild(cardEl);
    });
  }
}

function placeBid(projectIndex, card) {
  // Check if player can still play cards
  const cardsPlayed = gameState.cardsPlayedThisRound || 0;
  const maxCards = gameState.maxCardsPerRound || 1;
  
  console.log(`Breed: ${gameState.myData.breed}, Cards played: ${cardsPlayed}, Max: ${maxCards}`);
  
  if (cardsPlayed >= maxCards) {
    const breed = gameState.myData.breed;
    const message = breed === 'Labrador' ? 
      `You've already played ${maxCards} cards this round (Labrador limit)` :
      `You've already played your card this round`;
    showNotification(message);
    return;
  }
  
  const cardIndex = gameState.myData.handAction.indexOf(card);
  console.log('Placing bid - Project:', projectIndex, 'Card index:', cardIndex, 'Card:', card);
  
  socket.emit('place-bid', {
    projectIndex: projectIndex,
    cardType: 'action',
    cardIndex: cardIndex
  });
  
  // DON'T update local count - wait for server response
  // The server will tell us the updated count
  
  // Hide draw card button since we've played
  const drawBtn = document.getElementById('drawCardBtn');
  if (drawBtn) {
    drawBtn.style.display = 'none';
  }
  
  // Show notification based on expected result
  const expectedCards = cardsPlayed + 1;
  if (expectedCards >= maxCards) {
    const message = maxCards > 1 ? 
      `You've played ${expectedCards}/${maxCards} cards - turn limit reached!` :
      `Card played - you've reached your 1 card limit for this round`;
    showNotification(message);
  } else {
    showNotification('Bid placed!');
  }
  
  // DON'T update local state here - wait for server confirmation
  // The server will send back game-updated event if bid is valid
  // If invalid, we'll get bid-failed event
}

function endTurn() {
  console.log('\n=== END TURN CLICKED ===');
  console.log('Current game state:', gameState);
  console.log('Is my turn?', gameState.isMyTurn);
  console.log('My player ID:', myPlayerId);
  console.log('Socket ID:', socket.id);
  console.log('Socket connected?', socket.connected);
  
  if (!gameState.isMyTurn) {
    console.log('ERROR: Not my turn!');
    showNotification('Not your turn!');
    return;
  }
  
  console.log('Emitting end-turn event...');
  socket.emit('end-turn');
  showNotification('Ending turn...');
  document.getElementById('endTurnBtn').style.display = 'none';
  document.getElementById('drawCardBtn').style.display = 'none';
  console.log('=== END TURN SENT ===\n');
}

function drawCard() {
  console.log('=== DRAW CARD CLIENT DEBUG ===');
  console.log('Drawing a card instead of playing');
  console.log('Room code:', roomCode);
  console.log('Is my turn:', gameState.isMyTurn);
  console.log('Current hand size:', gameState.myData.handAction.length);
  console.log('Current player:', gameState.currentPlayer);
  console.log('My index:', gameState.myIndex);
  
  if (!gameState.isMyTurn) {
    showNotification('Not your turn!');
    return;
  }
  
  // First test if socket communication works at all
  console.log('Testing basic socket communication...');
  socket.emit('ping', { test: 'basic communication', timestamp: Date.now() });
  
  console.log('Testing draw-specific communication...');
  socket.emit('test-draw', { test: 'communication' });
  
  console.log('Emitting draw-card event to server...');
  socket.emit('draw-card', {
    roomCode: roomCode
  });
  showNotification('Drawing a card...');
  document.getElementById('drawCardBtn').style.display = 'none';
  document.getElementById('endTurnBtn').style.display = 'none';
  console.log('Draw card client request sent');
}

// Add test response handlers
socket.on('pong', (data) => {
  console.log('=== PONG RECEIVED ===', data);
});

socket.on('test-draw-response', (data) => {
  console.log('=== TEST RESPONSE RECEIVED ===', data);
});

function endDistraction() {
  console.log('Ending distraction phase');
  socket.emit('end-distraction');
  showNotification('Moving to next turn...');
  document.getElementById('endDistractionBtn').style.display = 'none';
}

// Breed tooltip
function showBreedTooltip(event, breed) {
  const tooltip = document.getElementById('tooltip');
  const power = BREED_POWERS[breed] || "No special power";
  
  tooltip.querySelector('.tooltip-title').textContent = breed;
  tooltip.querySelector('.tooltip-desc').textContent = power;
  
  tooltip.style.left = event.pageX + 10 + 'px';
  tooltip.style.top = event.pageY + 10 + 'px';
  tooltip.classList.add('show');
}

function hideTooltip() {
  document.getElementById('tooltip').classList.remove('show');
}

function showNotification(text) {
  const notif = document.createElement('div');
  notif.className = 'game-notification';
  notif.textContent = text;
  document.body.appendChild(notif);
  
  setTimeout(() => {
    notif.style.animation = 'slideInBounce 0.5s ease-out reverse';
    setTimeout(() => notif.remove(), 500);
  }, 2500);
}

function showProjectWinners(winners, callback) {
  if (!winners || winners.length === 0) {
    callback();
    return;
  }
  
  const overlay = document.createElement('div');
  overlay.className = 'announcement-overlay';
  
  let currentIndex = 0;
  
  function showNextWinner() {
    if (currentIndex >= winners.length) {
      setTimeout(() => {
        overlay.remove();
        callback();
      }, 500);
      return;
    }
    
    const winner = winners[currentIndex];
    const typeEmoji = {comm: 'üí¨', focus: '‚ö°', social: '‚ù§Ô∏è', phys: 'üí™'};
    
    // Build energy icons
    const energyIcons = [];
    if (winner.energyUsed) {
      Object.entries(winner.energyUsed).forEach(([type, value]) => {
        for (let i = 0; i < value; i++) {
          energyIcons.push(typeEmoji[type] || '?');
        }
      });
    }
    
    const announcement = document.createElement('div');
    announcement.className = 'winner-announcement';
    announcement.innerHTML = `
      <div class="winner-name">${winner.playerName}</div>
      <div class="winner-project">Completed: ${winner.projectName}</div>
      <div class="winner-energy">${energyIcons.join(' ')}</div>
      <div style="color: var(--teal); font-size: 1.2rem;">+${winner.reward} Spaces!</div>
    `;
    
    overlay.innerHTML = '';
    overlay.appendChild(announcement);
    
    currentIndex++;
    setTimeout(showNextWinner, 2500);
  }
  
  document.body.appendChild(overlay);
  showNextWinner();
}

function showTurnTransition(turnNumber, callback) {
  const transition = document.createElement('div');
  transition.className = 'turn-transition';
  transition.textContent = `TURN ${turnNumber}`;
  document.body.appendChild(transition);
  
  setTimeout(() => {
    transition.remove();
    callback();
  }, 2000);
}

// Setup instant distraction drop zone
function setupDropZone() {
  const dropZone = document.getElementById('distractionDropZone');
  if (!dropZone) return;
  
  // Remove existing listeners
  const newDropZone = dropZone.cloneNode(true);
  dropZone.parentNode.replaceChild(newDropZone, dropZone);
  
  newDropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    if (draggedCard && draggedCard.type === 'instant') {
      newDropZone.classList.add('drag-over');
      e.dataTransfer.dropEffect = 'move';
    }
  });
  
  newDropZone.addEventListener('dragleave', () => {
    newDropZone.classList.remove('drag-over');
  });
  
  newDropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    newDropZone.classList.remove('drag-over');
    
    if (draggedCard && draggedCard.type === 'instant') {
      // Show target selection dialog for targeted distractions
      if (draggedCard.targetRequired) {
        selectTargetForDistraction(draggedCard);
      } else {
        // Play non-targeted instant distraction
        socket.emit('play-instant-distraction', {
          roomCode: roomCode,
          cardId: draggedCard.id,
          target: null
        });
        showNotification(`Playing ${draggedCard.name}!`);
      }
      draggedCard = null;
      draggedCardElement = null;
      draggedCardIndex = null;
    }
  });
}

// Select target for instant distraction
function selectTargetForDistraction(card) {
  // Create target selection overlay
  const overlay = document.createElement('div');
  overlay.className = 'announcement-overlay';
  
  const container = document.createElement('div');
  container.style.background = 'white';
  container.style.padding = '2rem';
  container.style.borderRadius = '15px';
  container.style.textAlign = 'center';
  container.style.minWidth = '400px';
  
  container.innerHTML = `
    <h3 style="color: var(--coral); margin-bottom: 1rem;">Select Target for ${card.name}</h3>
    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">${card.effect}</p>
    <div id="targetButtons" style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;"></div>
    <button onclick="this.closest('.announcement-overlay').remove()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: var(--text-secondary); color: white; border: none; border-radius: 5px; cursor: pointer;">Cancel</button>
  `;
  
  overlay.appendChild(container);
  document.body.appendChild(overlay);
  
  // Add target buttons for each opponent
  const targetButtons = document.getElementById('targetButtons');
  if (gameState.opponents) {
    gameState.opponents.forEach(opp => {
      const btn = document.createElement('button');
      btn.style.padding = '0.5rem 1rem';
      btn.style.background = 'var(--teal)';
      btn.style.color = 'white';
      btn.style.border = 'none';
      btn.style.borderRadius = '5px';
      btn.style.cursor = 'pointer';
      btn.textContent = opp.name;
      btn.onclick = () => {
        socket.emit('play-instant-distraction', {
          roomCode: roomCode,
          cardId: card.id,
          target: opp.id
        });
        showNotification(`Playing ${card.name} on ${opp.name}!`);
        overlay.remove();
      };
      targetButtons.appendChild(btn);
    });
  }
}

// Initialize on load
window.addEventListener('DOMContentLoaded', () => {
  initializeTrack();
  
  // Initial render attempt
  setTimeout(() => {
    if (gameState) renderGame();
  }, 500);
});
</script>
</body>
</html>